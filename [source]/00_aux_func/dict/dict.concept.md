# Словари

В языках типа python и js словари являются хэштаблицами, тогда как в QSP нам доступны только три типа данных:

- числа
- строки
- кортежи (в редакции 5.8.0 это тоже строки)

По сути словарь представляет собой структуру, состоящую из пар `ключ - значение`. Это позволяет обращаться к значению по ключу.

Мы можем использовать динамический код для организации таких пар. В качестве ключей можно использовать переменные, а в качестве значений — значения, помещённые в эти переменные.

Для наглядности я написал вот такой словарь:

```js
$dict = {
	$kind = "деревянная_булава"
	$name = "Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине"
	number = 1
	$np = "оружие|одноручное|булава"
	stoim = 176
	weight = 50
	$color = "663300"
	$uron = {
		дробящий = 1000
		стрелковый = 125
	}
}

dynamic $dict
```

Как видно, в такой структуре данных мы можем хранить, как простые строки, числа и кортежи, так и другие словари. По сути вложенность словарей не ограничена, и при воспроизведении верхнего уровня словаря, мы получаем все вложенные словари, как значение одной из воспроизведённых переменных.

Однако в чистом виде эта структура может поломать данные в переменных с пересекающимися именами, поэтому для автора мы оставляем чистую структуру, только как своего рода синтаксический сахар, если нужно быстро написать словарь.

Технически же словарь будет иметь немного иную структуру данных.

## Общая структура

Поскольку ключами словаря являются имена переменных, в словаре нужно объявить по локальной переменной на каждый ключ.

Дабы исключить возможные пересечения имён с другими переменными, в самом словаре переменные должны иметь неудобные имена. В `easy.database` имена переменных внутри словарей оборачиваются в двойные символы нижнего подчёркивания:

```js
local $__name__
local $__weight__
```

Все переменные на уровне словаря имеют только текстовый тип для удобства. Однако данные, которые сохраняются в словаре могут быть разных типов. Поэтому непосредственно запись данных выглядит как значения в ячейках `'type'` и `'value'` указанного массива. Пример:

```js
local $__name__
$__name__['type'] = 'str'
$__name__['value'] = 'Дубина'
```

Cобственно на этом структура словаря и заканчивается.

Да, если мы выполним такой словарь просто как самостоятельный динмаический код, мы не увидим никакого результата, разве что на время забьём память. Однако, мы можем заранее написать функции, обслуживающие словари, которые и позволят автору взаимодействовать с данными, извлекать, обновлять, дополнять. Всё это возможно, если к основному динамическому коду словаря добавлять динамический код для работы с данными.

Например, если мы хотим узнать существует ли в словаре некий ключ, нам нужно только лишь получить размер массива, соответствующего этому ключу и вернуть результат. Вот такой динамический код мы присоединяем к коду словаря:

```js
result = arrsize('$__<<$args[0]>>__')
```

и таким образом, вызвав весь собранный код с помощью `dyneval`, с передачей ключа в качестве параметра, мы получим информацию о существовании ключа.

Вся функция проверки ключа в словаре будет выглядеть так:

```js
result = dyneval($args[0] + @em.RN + {result = arrsize('$__<<$args[0]>>__')}, $args[1])
```

, где `$args[0]` — словарь, `$args[1]` — ключ, `@em.RN` — константа символа переноса строки.

## Достоинства и недостатки

**Достоинства:**
+ Высокая скорость извлечения всех данных словаря.
+ Возможность вкладывать словари друг в друга
+ простота доступа к данным на любом из уровней
+ Простота генерации одноуровневых словарей

**Недостатки:**
- Ключи должны соответствовать требованиям к именам переменных в QSP.
- При изменении данных во вложенных словарях приходится извлекать подряд данные всех словарей до нужного уровня, пересобирать данные в самом нижнем словаре, затем возвращаться обратно и пересобирать все словари вплоть до верхнего уровня.
- нагрузка на память при большом числе вложенных словарей, или данных (может привести к переполнению хэша переменных в QSP)
- поскольку данные изолированы внутри словаря, извлечь из него одновременно все данные проблематично (но не невозможно).