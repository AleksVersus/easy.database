# Словари

Хочется подробно описать, как я пришёл к концепции словарей в QSP, которую излагаю здесь, однако это лирика, ибо, как всегда, развитие базиса предвосхищает надстройку: именно развитие библиотеки плеера до редакции 5.8.0 позволило создавать почти полноценные словари.

В языках типа python и js словари являются хэштаблицами, тогда как в QSP нам доступны только три типа данных:

- числа
- строки
- кортежи (в редакции 5.8.0 это тоже строки)

По сути словарь представляет собой структуру, состоящую из пар `ключ - значение`. Это позволяет обращаться к значению по ключу.

В QSP есть возможность создавать массивы, индексируемые через строки:

```js
$mass['string'] = 'longboard'
```

Однако такой подход имеет ряд существенных недостатков:

- нельзя вкладывать словари в словари (решается организацией ссылочной системы управления данными)
- нельзя проверить наличие ключа в словаре (решается ведением дополнительного массива с ключами, что возвращает нас к ведению таблицы данных, а это уже не словарь в его примитивном виде).

В редакции 5.7.0 организация словарей сводилась по сути к двум вариантам.

Самый очевидный — это записывать данные в виде валидного кода QSP, а затем воспроизводить с помощью оператора `dynamic`:

```js
$dict = {
	$kind = "деревянная_булава"
	$name = "Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине"
	number = 1
	$np = "оружие|одноручное|булава"
	stoim = 176
	weight = 50
	$color = "663300"
	$uron = {
		дробящий = 1000
		стрелковый = 125
	}
}

dynamic $dict
```

Этот способ так же имел ряд недостатков:

- возникала вероятность повреждения данных при пересечении имён переменных.
- можно извлекать только 

```js
$надтип = "штучный"
$тип = "предмет"
$вид = "деревянная_булава"
$название = "Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине"
$признаки = "оружие|одноручное|булава"
стоимость = 176
вес = 50
$цвет = "663300"
$урон = {
	дробящий = 1000
	стрелковый = 125
}
```

Как видно, здесь для описания предмета используются девять переменных. Переменная `урон` хранит в виде текста валидный код QSP, который требуется выполнить, чтобы получить значения других переменных.

Такой объект легче всего описать через словарь. Однако структура словарей в QSP не представлена, хотя есть возможность индексировать элементы массивов через строки.

Сложность словарей заключается в их структуре. В языках программирования типа пайтон, словари это хэш-таблицы. В нашем случае возможно использовать только строки.

Если мы переложим взаимодействие со словарями на специальные функции, то опять же теоретически мы сможем иметь доступ к элементам словаря, благодаря использованию этих функций, а механизм обслуживания словарей будет самостоятельно следить за правильным заполнением данных.

Иными словами мы оставим пользователю только интерфейс, всё остальное будет делать механизм обслуживания.

## Новая организация словаря

Самым простым вариантом организации словаря являются блоки вложенного динамического кода. Как пример. В исходном варианте у нас есть вот такой словарь:

> `[:деревянная_булава:] [name:Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине:name] [number] [np:[оружие] [одноручное] [булава]:np] [stoim:176] [weight:50][color:663300] [uron: u1:дробящий:u1 u2:стрелковый:u2 p1:1000 p2:125 :uron]`

Хранить данные удобнее было бы в таком виде.



### В чём удобство такого способа хранения

Из такого словаря легко получить данные, просто выполнив его как динамический код:

```js
dynamic $dict
```

Это быстро извлекает все данные верхнего уровня из словаря.

### Недостатки такого способа

Однако у такого примитивного подхода есть ряд недостатков:
- мы не можем отследить и учесть все случаи пересечения имён переменных при работе со словарём.
- мы вынуждены получать значения всех переменных в словаре, хотя нам бывает нужно извлечь только одно значение.
- мы не можем получить напрямую значение из вложенного словаря даже если знаем, что это словарь. Мы вынуждены сначала извлечь значения из словаря верхнего уровня, потом извлечь значения из словаря внутреннего уровня.

### Решение

#### Избегаем пересечения имён

Чтобы избежать пересечения имён, все данные в словаре нужно хранить в виде локальных переменных. К сожалению, это усложнит написание словарей, если писать их в примитивном исходном виде:

```js
$dict = {
	local $__name__ = "Дубина"
	local __weight__ = 50

}
```
Если автор вынужден самостоятельно прописывать все `local`, а так же правильные имена переменных, это сразу убивает весь смысл организаии словарей именно как механизма удобства записи и хранения информации. Поэтому для автора мы оставляем возможность писать словарь, как обычный код QSP, а механизм будет сам вносить данные в нужном виде.

Сразу возникают допущения и ограничения для организации словарей.
+ Ключи можно именовать любыми разрешёнными символами для имён переменных QSP, и даже числа в начале допустимы.
- Недопустим символ `$` в именах ключей, так как тип данных определяется автоматически.
- недопустимы вложения словарей, так как это приведёт либо к избытку, либо к потере данных.
- автоматически определяется только природа строковых и числовых данных. Списки и словари соотвтетсвенно не определяются.
- нельзя использовать точки в именовании ключей

#### 