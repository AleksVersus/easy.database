QSP-Game Поиск по таблице данных

Внимание!!! Эта функция использует несколько циклов, в т.ч. вложенных. Не используйте без острой необходимости.

!@ $0 - регулярное выражение по которому производится поиск.	Внимание!!! Будет найден элемент точно соответствующий регулярке!	Если тип колонки num или tuple- поиск на точное совпадение c числом или кортежем.
!@ $1 - колонка, по которой производим поиск
!@ $2 - идентификатор таблицы данных
!@ #3 - размер чанка (если таблица более 150 тыс элементов, размер чанка нужно выбирать более 10 тыс)
!@ %4 ... %18 - дополнительные фильтры в виде кортежей:	(колонка, значение, управление) - управление: 		[regexp] - регулярка. Точное соответствие. Не работает для колонок типа num и tuple		[callback] - функция колбэк принимающая, как аргумент значение элемента, и возвращающая 1 или 0, в зависимости от результатов фильтрации		[strict] (или не указанное значение) - проверяем на точное соответствие. - значение только текстового типа. Для поиска числа или кортежа, нужно преобразовать их к текстовому типу, затем они будут преобразованы обратно в нужный тип.
# edb.dt.find
if $args[2] = '': $args[2] = $EASY_DATABASE['current_data_table']
!@pp:if(edb_fuse):include
!@ проверка инициализации базы данных
if $EASY_DATABASE['ID'] = '': msg "edb.dt.find: Ошибка. База данных не инициализирована." & exit
!@ проверка существования указанной таблицы данных
if $args[2] = '': msg "edb.dt.find: Ошибка. Не указан идентификатор таблицы данных" & exit
if $arritem('$<<$args[2]>>', 'ID') <> $args[2]: msg "edb.dt.find: Ошибка. Таблица данных `<<$args[2]>>` не существует." & exit
!@pp:endif
!@ проверка существования колонки
if $args[1] = '': $args[1] = $arritem('$<<$args[2]>>', 'current_col')
!@pp:if(edb_fuse):include
if $args[1] = '': msg "edb.dt.find: Ошибка. Не указана колонка поиска." & exit
if arrsize('$<<$args[2]>>_<<$args[1]>>') < 1: msg "edb.dt.find: Ошибка. Колонка `<<$args[1]>>` не существует." & exit
!@pp:endif
!@ размер чанка по умолчанию
if args[3] = 0: args[3] = 10000
!@ номер последнего элемента в массиве args на старте:
args[20] = arrsize('$args') - 1
!@ стартовый номер чанка
args[21] = 1
!@ список колонок в таблице данных:
$args[22] = @edb.dt.columns($args[2])
!@ тип основной колонки для поиска
$args[29] = @edb.col.type($args[1], $args[2])
!@ объявлем локальные массивы, которые используются для хранения чанков.
!@ ВНИМАНИЕ!!! Не используйте данные массивы в своей игре
local edb_dt_find_chunk_array_1_, edb_dt_find_chunk_array_2_, edb_dt_find_chunk_array_3_
local edb_dt_find_chunk_array_4_, edb_dt_find_chunk_array_5_, edb_dt_find_chunk_array_6_
local edb_dt_find_chunk_array_7_, edb_dt_find_chunk_array_8_, edb_dt_find_chunk_array_9_
local edb_dt_find_chunk_array_10_, edb_dt_find_chunk_array_11_, edb_dt_find_chunk_array_12_
local edb_dt_find_chunk_array_13_, edb_dt_find_chunk_array_14_, edb_dt_find_chunk_array_15_
local edb_dt_find_chunk_count_

!@ -------------------------------------------- цикл обхода чанков -------------------------------------------
loop while args[21] < @edb.dt.height($args[2]) step args[21] += args[3]:
	!@ ---------------------- получаем чанк -------------------------
	edb_dt_find_temp_count_ = 1
	$args[23] = {
		pl 'callback: '
		pl [$args[0], $args[1], $args[2], $args[3], $args[4], $args[5]]
		$args[20] = 'edb_dt_find_chunk_array_<<edb_dt_find_chunk_count_>>_'
		copyarr $args[20], '$<<$args[3]>>_<<$args[0]>>', val($args[4]), val($args[5])
		edb_dt_find_chunk_count_ += 1
		$result = $args[2] + '[<<$args[0]>>:<<$args[20]>>]'
	}
	$args[24] = @edb.list.for_each($args[22], $args[23], $args[4], $str(args[21]), $str(args[3]))
	!@ ---------------------- получаем чанк -------------------------
	pl $args[24]
	!@ ---------------------------------------- цикл поиска по чанку ----------------------------------------
	!@ поиск производится до тех пор, пока не будет найден элемент, соответствующий регулярному выражению
	!@ а так же соответствующий регуляркам фильтров
	$args[27] = @em.tag.get_num($args[24], $args[1])
	loop args[25], args[26], args[28] = 1, -1, 0 while args[25]:
		if $args[29] = 'tuple':
			args[26] = arrpos('%'+$args[27], %args[0], args[26]+1)
		elseif $args[29] = 'num':
			args[26] = arrpos($args[27], args[0], args[26]+1)
		else:
			args[26] = arrcomp('$'+$args[27], $args[0], args[26]+1)
		end
		pl [$args[1], '$'+$args[27], $args[0], args[26]]
		pl @em.arr.print('$'+$args[27])
		if args[26] <> -1 and args[28] <> args[26]:
			args[28] = args[26]
			if args[20] > 3:
				!@ если номер последнего args на старте больше 3, значит переданы доп фильтры
				!@ перебираем доп фильтры циклом (массив $args с четвёртого элемента по args[20]):
				args[35] = 1 & !@ маркер фильтрации. 0 - фильтр не пройден
				!@ -------------------------------- цикл перебора фильтров --------------------------------
				loop args[30] = 4 while args[30] <= args[20] step args[30] += 1:
					!@ получаем колонку, значение, управление
					$args[31], $args[32], $args[33] = %args[args[30]]
					$args[33] = $lcase($args[33])
					if @edb.list.is_el($args[22], $args[31]):
						!@ указанная колонка присутствует в таблице данных. Получаем тип:
						$args['34'] = $arritem('$<<$args[2]>>', 'column.<<$args[31]>>.type')
						if instr($args[33], '[regexp]') and no instr('[num][tuple]', '[<<$args[34]>>]'):
							!@ сравниваем на регулярку, если тип колонки не число и не кортеж
							if no strcomp($arritem('$<<$args[2]>>_<<$args[31]>>', args[26]), $args[32]):
								!@ фильтр не пройден
								args[35] = 0 & jump 'filter_end'
							end
						elseif instr($args[33], '[callback]') <> 0:
							!@ проверка по колбэку
							if $args[34] = 'tuple' and no dyneval($args[32], arritem('%<<$args[2]>>_<<$args[31]>>', args[26])):
								!@ колбэк вернул false - фильтр не пройдена
								args[35] = 0 & jump 'filter_end'
							elseif $args[34] = 'num' and no dyneval($args[32], arritem('<<$args[2]>>_<<$args[31]>>', args[26])):
								!@ колбэк вернул false - фильтр не пройдена
								args[35] = 0 & jump 'filter_end'
							elseif no dyneval($args[32], $arritem('$<<$args[2]>>_<<$args[31]>>', args[26])):
								!@ колбэк вернул false - фильтр не пройдена
								args[35] = 0 & jump 'filter_end'
							end
						else:
							!@ проверка на точное совпадение
							if $args[34] = 'tuple' and @em.str.to_tpl($args[32]) <> arritem('%<<$args[2]>>_<<$args[31]>>', args[26]):
								!@ значения не равны
								args[35] = 0 & jump 'filter_end'
							elseif $args[34] = 'num' and val($args[32]) <> arritem('<<$args[2]>>_<<$args[31]>>', args[26]):
								!@ значения не равны
								args[35] = 0 & jump 'filter_end'
							elseif $args[32] <> $arritem('$<<$args[2]>>_<<$args[31]>>', args[26]):
								!@ значения не равны
								args[35] = 0 & jump 'filter_end'
							end
						end
					end
				end
				!@ -------------------------------- цикл перебора фильтров --------------------------------
				:filter_end
				if args[35] = 1:
					!@ все фильтры пройдены, это наше значение
					args[25] = 0
				end
			else:
				!@ если доп фильтры не переданы, можно прервать проверку, т.к. нужный элемент найден
				args[25] = 0
			end
		else:
			args[25] = 0 & !@ прерываем цикл
		end
	end
	!@ ---------------------------------------- цикл поиска по чанку ----------------------------------------

	if args[26] <> -1:
		!@ если элемент найден, вычисляем идентификатор его строки и возвращаем элемент
		$result = $arritem('$<<$args[2]>>_id', args[26]+args[21])
		exit
	!@ else:
		!@ если элемент не найден, можно прошерстить следующий чанк.
		!@ увеличиваем стартовый номер чанка в step,
		!@ повторяем
	end
end
!@ -------------------------------------------- цикл обхода чанков -------------------------------------------
--- edb.dt.find ---------------------------------

Чтобы избежать пересечения имён массивов, я максимально убрал из данной функции локальные массивы. Локальные массивы используются только для хранения чанков. См объявление локальных переменных по коду.

args[20] — номер последнего элемента в массиве args на старте. Не должен быть меньше 3
args[21] - стартовый номер чанка
$args[22] - список колонок в таблице данных
$args[23] - функция колбэк
$args[24] - псевдословарь соответствия оригинальной колонки чанку.
args[25] - маркер цикла. Пока равен 1, цикл запущен.
args[26] - следующая позиция, с которой начинается поиск.
$args[27] - название временного массива с чанком
args[28] - предохранитель от непрерывности для цикла
$args[29] - тип основной колонки
args[30] - счётчик цикла для перебора фильтров
$args[31], $args[32], $args[33] - колонка, значение, управление фильтра
$args[34] - тип колонки в цикле доп фильтров
args[35] - цикл фильтров. Маркер true|false - пройдены ли все фильтры или нет

!@pp:if(build_easy_math!=Off):nopp
!@pp:var(em_tag_getnum)
!@pp:endif

{for_each:
	0 - column list
	1 - callback
	2 - table
	3 - chunk_start
	4 - chunk size
	{:callback
		0 - item
		1 - tail
		2 - result
		3 - table (1)
		4 - chunk start (2)
		5 - chunk size (3)
	}
}