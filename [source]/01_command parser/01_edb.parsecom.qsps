QSP-Game локация для распарсивания команд
$args[0] - полный список команд
$args[1]...$args[18] — значения, которые нельзя было уместить в списке команд

Команды можно принимать как одиночные, так и целым списком.
Каждая команда должна записываться отдельной строкой, никаких объединений (кроме возможно транзакций)

Распарсиваем с помощью instr, отыскивая в команде точку и фигурную скобку.

1. Если точка найдена раньше, значит имеем дело со сылками к объектам команды, последовательно извлекаем объекты
2. Если фигурная скобка найдена раньше точки, значит дальше идут исключительно аргументы, и мы парсим аргументы
3. Если не найдены ни точки ни фигурные скобки, значит команда кончилась и мы скорее всего имеем дело с неявным методом

# edb
!@ объявляем локальные переменные
local $command_list
local $last_object	& !@ последний объект в цепочке объектов, с которым мы имели дело
local $dyn_code		& !@ переменная для хранения динамического кода
local $parse_arguments & !@ массив для временного хранения распарсенных аргументов
*pl 'edb'+$args[0]
!@ разбиваем команды на отдельные строки и помещаем в массив
@em.str.inArr($args[0],'$command_list','',"[notspace][trim][strip]")
*pl arrsize('$command_list')
loop local i,size=0,arrsize('$command_list') while i<size step i+=1:
	!@ непосредственно здесь уже парсим каждую отдельную команду
	local $command_objects, $command_arguments	& !@ сюда помещаем списки объектов и аргументов к этим объектам
	dynamic {
		!@ внутрь динамика передаётся команда. Это позволяет использовать внутри динамика локальные переменные
		local $command=$args[0]	& !@ присваиваем команду локальной переменной
		$command
		local dot_instr, brk_instr, cls_instr	& !@ вхождение точки и вхождения скобок
		loop while len($command)>0:
			dot_instr=instr($command,'.')	& !@ вхождение точки в команду
			brk_instr=instr($command,'{')	& !@ вхождение открывающей скобки в команду
			if dot_instr=1:
				$command=$mid($command,2)
			elseif brk_instr=0 or (dot_instr<brk_instr and dot_instr<>0):
				$command_objects[]=$mid($command,1,dot_instr-1)
				$command_arguments[]=''	& !@ этим символом помечаем, что команда отсутствует
				$command=$mid($command,dot_instr+1)
				!@ *pl (('comm ',$command_objects[],'-',$command_arguments[],'-',$command))
			elseif dot_instr=0 or (brk_instr<dot_instr and brk_instr<>0):
				$command_objects[]=$mid($command,1,brk_instr-1)
				cls_instr=instr($command,'}')
				$command_arguments[]=$mid($command,brk_instr,cls_instr-(brk_instr-1))
				$command=$mid($command,cls_instr+1)
				!@ *pl (('args ',$command_objects[],'-',$command_arguments[],'-',$command))
			end
		end
	},$command_list[i]
	!@ на данном этапе у нас есть список ссылок к объектам в массивах $command_objsects и $command_arguments
	!@ обрабатываем команды ($last_object - служит для хранения последней ссылки на объект из цепочки)
	loop local i,size=0,arrsize('$command_objects') while i<size step i+=1 & $last_object=$command_objects[i]:
		!@ *pl (($command_objects[i],' > ',$command_arguments[i]))
		if $command_arguments[i]='':
			!@ объект, с которым мы работаем, не является методом
			if $command_objects[i]='bd':
				!@ объект, с которым мы работаем, является базой данных
				$last_object['type'],$last_object['id'],$last_object['content']=@edb.bd.implicit()	& !@ неявный метод вызываем всегда
			elseif $last_object['type']='data_base' and @edb.list.isEl($last_object['content'],$command_arguments[i]):
				!@ если предыдущий объект база данных, а мы имеем дело с таблицей данных, которая в этой базе данных существует
				$last_object['type'],$last_object['id'],$last_object['content']=@edb.dt.implicit($command_objects[i])	& !@ неявный метод вызываем всегда
			end
			!@ в результат всегда возвращаем данные из неявного метода
			$result=($last_object['type'],$last_object['id'],$last_object['content'])
		else
			!@ объект, с которым мы работаем, является методом
			if $last_object['type']='data_base':
				!@ это метод для базы данных
				if $command_objects[i]='newTable':
					!@ метод создания новой таблицы данных
					if $command_arguments[i]<>'{}':
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						@edb.bd.newTable($parse_arguments[0],$parse_arguments[1])
					else
						msg "edb: bd: Метод newTable получил пустой аргумент."
					end
				elseif  $command_objects[i]='delTables':
					!@ метод удаления таблиц
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size,num=0,arrsize('$parse_arguments'),0 while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								num = $strfind($parse_arguments[i],'%args(\d+)%',1)
								if num<>0: $parse_arguments[i]=$args[num]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						$dyn_code="@edb.bd.delTables('<<$command_arguments[i]>>',$parse_arguments[0]"
						loop local i,size=1,arrsize('$parse_arguments') while i<size step i+=1:
							$dyn_code+=",$parse_arguments[<<i>>]"
						end
						$dyn_code+=")"
						dynamic $dyn_code
					else
						msg "edb: bd: Метод delTables получил пустой аргумент."
					end
				end
			end
		end
	end
	!@ теперь необходимо удалить команды, чтобы на следующей итерации выполнять другую команду
	killvar '$command_objects' & killvar '$command_arguments'
end
--- edb ---------------------------------

!@pp:var(em_str_inarr)
