QSP-Game локация для распарсивания команд
$args[0] - полный список команд
$args[1]...$args[18] — значения, которые нельзя было уместить в списке команд

Команды можно принимать как одиночные, так и целым списком.
Каждая команда должна записываться отдельной строкой, никаких объединений (кроме возможно транзакций)

Распарсиваем с помощью instr, отыскивая в команде точку и фигурную скобку.

1. Если точка найдена раньше, значит имеем дело со сылками к объектам команды, последовательно извлекаем объекты
2. Если фигурная скобка найдена раньше точки, значит дальше идут исключительно аргументы, и мы парсим аргументы
3. Если не найдены ни точки ни фигурные скобки, значит команда кончилась и мы скорее всего имеем дело с неявным методом

# edb
args[19]=args[19]	& !@ нужно будет использовать переменные args, чтобы избежать пересечений имён с другими переменными
!@ объявляем локальные переменные
local $command_list
local $last_object	& !@ последний объект в цепочке объектов, с которым мы имели дело
local $dyn_code		& !@ переменная для хранения динамического кода
local $parse_arguments & !@ массив для временного хранения распарсенных аргументов
!@ разбиваем команды на отдельные строки и помещаем в массив
@em.str.inArr($args[0],'$command_list','',"[notspace][trim][strip]")
!@ pl 'edb: Команд на входе: <<arrsize("$command_list")>>' & wait 0	& !@< выводим лог
!@ теперь с помощью цикла перебираем все команды
loop local i,size=0,arrsize('$command_list') while i<size step i+=1:
	!@ непосредственно здесь уже парсим каждую отдельную команду
	local $command_objects, $command_arguments	& !@ сюда помещаем списки объектов и аргументов к этим объектам
	dynamic {
		!@ внутрь динамика передаётся команда. Это позволяет использовать внутри динамика локальные переменные
		local $command=$args[0]	& !@ присваиваем команду локальной переменной
		!@ pl 'Парсер. Команда[<<i>>]: '+$command & wait 100 	& !@< выводим команду
		local dot_instr, brk_instr, cls_instr	& !@ вхождение точки и вхождения скобок
		loop while len($command)>0:
			dot_instr=instr($command,'.')	& !@ вхождение точки в команду
			brk_instr=instr($command,'{')	& !@ вхождение открывающей скобки в команду
			!@ pl "dot <<dot_instr>> brk <<brk_instr>>" & wait 100	& !@< comment
			if dot_instr=1:
				$command=$mid($command,2)
			elseif brk_instr=0 and dot_instr=0:
				$command_objects[]=$command
				$command_arguments[]=''
				killvar '$command'
				!@ pl "single Object" & wait 100	& !@< comment
			elseif brk_instr=0 or (dot_instr<brk_instr and dot_instr<>0):
				$command_objects[]=$mid($command,1,dot_instr-1)
				$command_arguments[]=''	& !@ этим символом помечаем, что команда отсутствует
				$command=$mid($command,dot_instr+1)
				!@ pl (('comm ',$command_objects[],'-',$command_arguments[],'-',$command)) & wait 100	& !@< comment
			elseif dot_instr=0 or (brk_instr<dot_instr and brk_instr<>0):
				$command_objects[]=$mid($command,1,brk_instr-1)
				cls_instr=instr($command,'}')
				$command_arguments[]=$mid($command,brk_instr,cls_instr-(brk_instr-1))
				$command=$mid($command,cls_instr+1)
				!@ pl (('args ',$command_objects[],'-',$command_arguments[],'-',$command)) & wait 100	& !@< comment
			end
		end
	},$command_list[i]
	!@ на данном этапе у нас есть список ссылок к объектам в массивах $command_objsects и $command_arguments
	!@ pl 'Парсер. Команда. Объектов в цепочке: '+$str(arrsize('$command_objects'))
	!@ обрабатываем команды ($last_object - служит для хранения последней ссылки на объект из цепочки)
	loop local i,size=0,arrsize('$command_objects') while i<size step i+=1:
		!@ pl 'edb: Объект: <<$command_objects[i]>> Аргументы: <<$command_arguments[i]>>' & wait 100 	& !@< 
		!@ pl "Last Objects: <<$last_object['type']>>,<<$last_object['id']>>,<<$last_object['content']>>" & wait 100 	& !@< 
		if $command_arguments[i]='':
			!@ объект, с которым мы работаем, не является методом
			!@ pl 'Объект в цепочке: <<$command_objects[i]>>' & wait 100 	& !@< выводим команду
			if $last_object['type']='unknown':
				msg "Попытка обращения к несуществующему объекту «<<$last_object['id']>>». Предыдущий объект в цепочке «<<$last_object['content']>>»"
				jump 'end_command'
			elseif $last_object['type']=''and $command_objects[i]='bd':
				!@ если предыдущего объекта в цепочке нет и ссылка похожа на ссылку на базу данных		
				!@ значит объект, с которым мы работаем, является базой данных
				set $last_object['type'],$last_object['id'],$last_object['content']=@edb.bd.implicit()	& !@ неявный метод вызываем всегда
			elseif $last_object['type']='data_base' and @edb.list.is_el($last_object['content'],$command_objects[i]):
				!@ если предыдущий объект база данных, а мы имеем дело с таблицей данных, которая в этой базе данных существует
				set $last_object['type'],$last_object['id'],$last_object['content']=@edb.dt.implicit($command_objects[i])	& !@ неявный метод вызываем всегда
			elseif $last_object['type']='data_table' and @edb.list.is_el($last_object['content'],$command_objects[i]):
				!@ если предыдущий объект Таблица данных, а мы имеем дело с колонкой, которая в этой таблице данных существует
				set $last_object['type'],$last_object['id'],$last_object['content']=@edb.col.implicit($EASY_DATABASE['current_data_table'],$command_objects[i])	& !@ неявный метод вызываем всегда
			elseif $last_object['type']='data_table' and no @edb.list.is_el($last_object['content'],$command_objects[i]):
				!@ если предыдущий объект Таблица данных, а мы имеем дело с не колонкой, которая в этой таблице данных существует
				!@ значит, вероятнее всего мы имеем дело со строкой. тогда надо проверить правда ли это строка
				args['isRow']=@edb.row.is_there($EASY_DATABASE['current_data_table'],$command_objects[i])
				if args['isRow']:
					!@ если это строка, тогда мы вызываем неявный метод к строке
					set $last_object['type'],$last_object['id'],$last_object['content']=@edb.row.implicit($EASY_DATABASE['current_data_table'],$command_objects[i],args['isRow'])	& !@ неявный метод вызываем всегда
				else
					!@ если это не строка, то это непонятно что
					set $last_object['type'],$last_object['id'],$last_object['content']='unknown',$command_objects[i],$command_objects[i-1]
				end
			elseif $last_object['type']='table_col':
				!@ если предыдущий объект был колонка, значит мы сто процентов имеем дело со строкой. Не важно, существует она или нет,
				!@ мы пытаемся с ней работать. Определяем, не число ли упавший к нам идентификатор
				!@ !!! ЭТО ПРИМИТИВНЕЙШЕЕ ОПРЕДЕЛЕНИЕ, чтобы не грузить и без того перегруженный алгоритм
				args['isRow']=iif(@eedb.row.is_num($command_objects[i]),1,2)
				set $last_object['type'],$last_object['id'],$last_object['content']=@edb.row.implicit($EASY_DATABASE['current_data_table'],$command_objects[i],args['isRow'])	& !@ неявный метод вызываем всегда
				!@ однако поскольку мы сослались и на столбец и на строку, значит мы уже работаем с ячейкой!
				if $EASY_DATABASE['current_id']<>'':
					$args['currow']=$EASY_DATABASE['current_id']
					args['isRow']=2
				else
					$args['currow']=$EASY_DATABASE['current_row']
					args['isRow']=1
				end
				set $last_object['type'],$last_object['id'],$last_object['content']=@edb.cell.implicit($EASY_DATABASE['current_data_table'],$EASY_DATABASE['current_col'],$args['currow'],args['isRow'])	& !@ неявный метод вызываем всегда

			end
		else
			!@ объект, с которым мы работаем, является методом
			!@ pl 'Объект в цепочке: «<<$command_objects[i]>>», Тип предыдущего <<$last_object["type"]>>' & wait 100 	& !@< выводим команду
			if $last_object['type']='unknown':
				msg "Попытка обращения к несуществующему объекту «<<$last_object['id']>>». Предыдущий объект в цепочке «<<$last_object['content']>>»"
				jump 'end_command'
			elseif $last_object['type']='data_base':
				!@ pl 'edb: bd: Команда для базы данных' & wait 100 	& !@< выводим
				!@ это метод для базы данных
				if $command_objects[i]='new_table':
					!@ метод создания новой таблицы данных
					!@ pl 'Парсер. new_table: <<$command_arguments[i]>>' & wait 100 	& !@< выводим
					if $command_arguments[i]<>'{}':
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[strip]")
						@edb.bd.new_table($parse_arguments[0],$parse_arguments[1])
					else
						msg "edb: bd: Метод new_table получил пустой аргумент."
					end
				elseif $command_objects[i]='delTables':
					!@ метод удаления таблиц
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						$dyn_code="@edb.bd.delTables($parse_arguments[0]"
						loop local i,size=1,arrsize('$parse_arguments') while i<size step i+=1:
							$dyn_code+=",$parse_arguments[<<i>>]"
						end
						$dyn_code+=")"
						dynamic $dyn_code
					else
						msg "edb: bd: Метод delTables получил пустой аргумент."
					end
				elseif $command_objects[i]='print':
					if $command_arguments[i]<>'{}':
						$command_arguments[i]=@edb.slice($command_arguments[i])
						if strcomp($command_arguments[i],'%args\d+%'):
							!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
							args['num'] = val($strfind($command_arguments[i],'%args(\d+)%',1))
							if args['num']<>0: $command_arguments[i]=$args[args['num']]
						end
						@edb.bd.print($command_arguments[i])
					else
						@edb.bd.print()
					end
				elseif $command_objects[i]='comment':
					!@ фиктивный метод comment позволяет добавлять фиктивные команды с комментариями
				else
					msg "edb: bd: Неизвестный метод для Базы Данных <<$command_objects[i]>>"
				end
			elseif $last_object['type']='data_table':
				!@ pl 'edb: dt: Команда для таблицы данных' & wait 100 	& !@< выводим
				!@ значит мы обрабатываем методы для таблицы данных
				if $command_objects[i]='print':
					!@ pl 'edb: dt: Команда print для <<$command_objects[i]>>' & wait 100 	& !@< выводим
					!@ вывод на экран информации о таблице данных
					if $command_arguments[i]<>'{}':
						$command_arguments[i]=@edb.slice($command_arguments[i])
						if strcomp($command_arguments[i],'%args\d+%'):
							!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
							args['num'] = val($strfind($command_arguments[i],'%args(\d+)%',1))
							if args['num']<>0: $command_arguments[i]=$args[args['num']]
						end
						!@ в $command_objects[i-1] как раз остался идентификатор талицы данных
						@edb.dt.print($EASY_DATABASE['current_data_table'],$command_arguments[i])
					else
						@edb.dt.print($EASY_DATABASE['current_data_table'])
					end
				elseif $command_objects[i]='setCur':
					!@ метод выставления таблицы, как текущей.
					!@ Не вижу ситуаций, когда бы была необходимость вызывать данный метод
					@edb.dt.set_cur($command_objects[i-1])
				elseif $command_objects[i]='newCol':
					if $command_arguments[i]<>'{}':
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ $EASY_DATABASE['current_data_table'] - идентфикатор таблицы данных,
						!@ $parse_arguments[0] - идентификатор столбца
						!@ $parse_arguments[1] - тип столбца
						@edb.dt.newCol($EASY_DATABASE['current_data_table'],$parse_arguments[0],$parse_arguments[1])
					else
						msg "edb: dt: Метод newCol{} получил пустой аргумент."
					end
				elseif $command_objects[i]='delCols':
					!@ метод удаления таблиц
					!@ pl 'edb: dt: Метод delCols{}' & wait 100 	& !@< выводим
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						$dyn_code="@edb.dt.delCols($EASY_DATABASE['current_data_table']"
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							!@ pl 'edb: dt: Аргументы <<$parse_arguments[i]>>' & wait 100 	& !@< выводим
							$dyn_code+=",$parse_arguments[<<i>>]"
						end
						$dyn_code+=")"
						!@ pl $dyn_code & wait 100 	& !@< выводим
						dynamic $dyn_code
					else
						msg "edb: dt: Метод delCols получил пустой аргумент."
					end
				elseif $command_objects[i]='newRow':
					!@ метод удаления таблиц
					!@ pl 'edb: dt: Метод newRow{}' & wait 100 	& !@< выводим
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						$dyn_code="@edb.dt.newRow($EASY_DATABASE['current_data_table']"
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							!@ pl 'edb: dt: Аргумент <<$parse_arguments[i]>>' & wait 100 	& !@< выводим
							$dyn_code+=",$parse_arguments[<<i>>]"
						end
						$dyn_code+=")"
						!@ pl $dyn_code & wait 100 	& !@< выводим
						dynamic $dyn_code
					else
						@edb.dt.newRow($EASY_DATABASE['current_data_table'])
					end
				elseif $command_objects[i]='delRows':
					!@ метод удаления строк
					!@ pl 'edb: dt: Метод delRows{}' & wait 100 	& !@< выводим
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						$dyn_code="@edb.dt.delRows($EASY_DATABASE['current_data_table']"
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							!@ pl 'edb: dt: Аргументы <<$parse_arguments[i]>>' & wait 100 	& !@< выводим
							$dyn_code+=",$parse_arguments[<<i>>]"
						end
						$dyn_code+=")"
						!@ pl $dyn_code & wait 100 	& !@< выводим
						dynamic $dyn_code
					else
						msg "edb: dt: Метод delRows получил пустой аргумент."
					end
				elseif $command_objects[i]='setIdCol':
					!@ метод удаления таблиц
					!@ pl 'edb: dt: Метод setIdCol{}' & wait 100 	& !@< выводим
					if $command_arguments[i]<>'{}':
						!@ распарсиваем аргументы для метода в массив $parse_arguments
						@em.str.inArr(@edb.slice($command_arguments[i]),'$parse_arguments',',',"[notspace][trim][strip]")
						!@ подменяем ссылки на аргументы значениями
						loop local i,size=0,arrsize('$parse_arguments') while i<size step i+=1:
							if strcomp($parse_arguments[i],'%args\d+%'):
								!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
								args['num'] = val($strfind($parse_arguments[i],'%args(\d+)%',1))
								if args['num']<>0: $parse_arguments[i]=$args[args['num']]
							end
						end
						!@ теперь собираем строку вызова метода удаления таблиц данных
						@edb.dt.setIdCol($EASY_DATABASE['current_data_table'],$parse_arguments[0])
					else
						msg "edb: dt: Пустой аргумент метода setIdCol{}."
					end
				else
					msg "edb: dt: Неизвестный метод <<$command_objects[i]>>{}"
				end
			elseif $last_object['type']='table_col':
				if $command_objects[i]='print':
					if $command_arguments[i]<>'{}':
						$command_arguments[i]=@edb.slice($command_arguments[i])
						if strcomp($command_arguments[i],'%args\d+%'):
							!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
							args['num'] = val($strfind($command_arguments[i],'%args(\d+)%',1))
							if args['num']<>0: $command_arguments[i]=$args[args['num']]
						end
						@edb.col.print($EASY_DATABASE['current_data_table'],$EASY_DATABASE['current_col'],$command_arguments[i])
					else
						@edb.col.print($EASY_DATABASE['current_data_table'],$EASY_DATABASE['current_col'])
					end
				elseif $command_objects[i]='setCur':
					!@ метод выставления колонки, как текущей.
					!@ Не вижу ситуаций, когда бы была необходимость вызывать данный метод
					@edb.col.setCur($EASY_DATABASE['current_data_table'],$command_objects[i-1])
				else
					msg "edb: col: Неизвестный метод <<$command_objects[i]>>{}"
				end
			elseif $last_object['type']='table_string':
				if $command_objects[i]='print':
					if $EASY_DATABASE['current_id']<>'':
						$args['currow']=$EASY_DATABASE['current_id']
						$args['++args']='[idtype:2]'
					else
						$args['currow']=$EASY_DATABASE['current_row']
						$args['++args']='[idtype:1]'
					end
					if $command_arguments[i]<>'{}':
						$command_arguments[i]=@edb.slice($command_arguments[i])
						if strcomp($command_arguments[i],'%args\d+%'):
							!@ если в качестве аргумента передана ссылка, заменяем её на значение из $args
							args['num'] = val($strfind($command_arguments[i],'%args(\d+)%',1))
							if args['num']<>0: $command_arguments[i]=$args[args['num']]
						end
						if instr($command_arguments[i],'[idtype:')<>0: $args['++args']=''
						@edb.row.print($EASY_DATABASE['current_data_table'],$args['currow'],$command_arguments[i]+$args['++args'])
					else
						@edb.row.print($EASY_DATABASE['current_data_table'],$args['currow'],$args['++args'])
					end
				elseif $command_objects[i]='setCur':
					!@ метод выставления строки, как текущей.
					!@ Не вижу ситуаций, когда бы была необходимость вызывать данный метод
					@edb.row.setCur($EASY_DATABASE['current_data_table'],$command_objects[i-1])
				else
					msg "edb: col: Неизвестный метод <<$command_objects[i]>>{}"
				end
			end
		end
	end
	:end_command
	!@ теперь необходимо удалить команды, чтобы на следующей итерации выполнять другую команду
	killvar '$command_objects' & killvar '$command_arguments' & killvar '$last_object' & killvar '$parse_arguments'
end
!@ в результат всегда возвращаем данные из неявного метода
$result=($last_object['type'],$last_object['id'],$last_object['content'])
--- edb ---------------------------------

!@pp:var(em_str_inarr)
