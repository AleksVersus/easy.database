# Easy.DataBase

Система управления базой данных — это комплексный модуль (библиотека), предназначенный для простого редактирования нереляционной базы данных на QSP.

Существует модуль Олегуса, реализующий то же самое, но через другие механизмы: https://forum.ifiction.ru/viewtopic.php?id=1522.

## Подключение

"easy.database" подключается как любой другой модуль QSP, то есть с использованием команды `inclib`. Скачайте архив со [страницы релизов](https://github.com/AleksVersus/easy.nrBD/releases), распакуйте и скопируйте папку "`lib`" в папку с вашей игрой. Тогда на самой первой локации в игре достаточно будет прописать такую команду подключения:

```qsp
inclib 'lib/easy.database.qsp'
```

Для работы модуля требуется так же подключить и библиотеку "easy.math". Она поставляется вместе с модулем. Подключение аналогичное:

```qsp
inclib 'lib/easy.math.qsp'
```

Если вы уже используете библиотеку "easy.math" в своей игре, убедитесь, что версия "easy.math" совместима с "easy.database". Для этого в любом месте вашей игры используйте команду:

```qsp
*pl @edb.start('em-version')
```

При запуске игры вы увидите на экране текущую и необходимую версии модуля "easy.math".

### Работа с исходниками

Если вы пишете игру, используя Sublime Text с подключённым пакетом QSP, у вас есть возможность самостоятельно собирать модуль из исходников.

В папке "`[source]`" размещены исходные тексты модуля, а так же файл "`project.json`", отредактировав который вы наладите сборку модуля в папку с вашей игрой.

Так же вы можете собирать игру, напрямую включая в неё все локации модуля, если это необходимо. В этом случае вам не потребуется подключать модуль к игре — он уже будет в неё встроен.

В исходниках предусмотрены два режима сборки: без обработки препроцессором и с обработкой препроцессором.

В первом случае модуль будет собран, как есть, включая все служебные комментарии и наборы "предохранителей" — сообщений, которые всплывают в виде модальных окон и предупреждают о некоторых наиболее распространённых ошибках при работе с модулем. Данный режим сборки необходим на этапе разработки, отладки и тестирования игры.

Во втором случае необходимо включить препроцессор в "`project.json`", тогда из собранного модуля будут удалены все служебные комментарии, а так же блоки "предохранителей". Данный режим рекомендуется использовать при сборке релизной версии игры, когда большая часть ошибок уже отловлена.

Вы также можете включить препроцессор, но сохранить блоки предохранителей в конечной сборке модуля. Для этого в исходном файле "`00_edb.start.qsps`" в любом месте пропишите строку:

```qsp
!@pp:var(fuse)
```

**Обратите внимание!** Исходники библиотеки "easy.math" необходимо скачивать отдельно: [easy.math на github](https://github.com/AleksVersus/easy.math.3)

### Подключение встроенного отладчика

Вы можете подключить отладочные команды модуля к командной строке (полю ввода), прописав в самом начале игры следующую команду:

```qsp
$usercom[] = 'edb.usercom'
```

Это добавит новый обработчик строки ввода к уже работающим. Обратите внимание на квадратные скобки. Если вы используете свой собственный обработчик строки ввода и хотите, чтобы обработчик модуля работал совместно (параллельно) с вашим, обязательно ставьте квадратные скобки после `$usercom`.

Все команды модуля должны начинаться с ключевого слова `edb`. Для вывода списка всех доступных команд, введите в строке ввода `edb help`.

Также список всех доступных команд для поля ввода представлен в разделе данной документации "Команды отладки".

## Особенности работы

Технически база данных представляет собой наборы массивов, описывающих таблицы данных, а так же массивы, реализующие поведение колонок в таблицах данных. Основные свойства базы данных записываются в массив $EASY_DATABASE.

Поскольку все массивы, входящие в базу данных являются глобальными, недопустимо использовать их в других местах игры. Ввиду чего необходимо чётко понимать, какие имена будут заняты под базу данных. Эту информацию можно проверить, воспользовавшись функцией `edb.print`, или через встроенный отладчик, введя команду `edb >`.

При создании таблицы данных инициализируется массив, название которого совпадает с названием идентификатора таблицы данных, поэтому требования к такому идентификатору такие же, как и к названию массива, плюс идентификатор не должен начинаться с символа `$`.

Также при создании таблицы данных автоматически генерируется колонка первичных ключей. Она является служебной, и с ней нельзя напрямую взаимодействовать, хотя технически это такой же массив, как и все прочие, поэтому при желании вы можете изменять колонку первичных ключей, используя чистый QSP. Колонка первичных ключей всегда представляет собой массив, название которого состоит из идентификатора таблицы данных и слова '`_id`'.

Примеры имён массивов, представляющих колонки первичных ключей для разных таблиц данных:

```qsp
$objects_id
$dialogs_id
$potions_id
$temp_id
```

Основные функции, реализующие работу с базой данных, представленны в виде локаций-функций. Названия всех таких локаций начинаются с `edb`. Для удобства чтения кода названия локаций содержат точки, это не мешает использовать их при неявном вызове `func`:

```qsp
@edb.row.fill('Старый меч', 'сумка', 1, ($i, 'objects'))
```

Также для улучшения семантики в названиях локаций-функций указывается сущность, с которой они работают, и только затем непосредственно названия функций. Исключение составляют функции, работающие непосредственно с сущностью базы данных:

```qsp
@edb.init()
@edb.print('[all arrays]'')
```

Некоторые вспомогательные функции тоже не имеют в названии указания на сущность, с которой работают:

```qsp
@edb.gen_next_hex('0000ff', 6)
```

В базе данных работает система указателей, которые позволяют не писать каждый раз в каждой команде полностью, с какой строкой, колонкой и таблицей сейчас нужно работать. Указатели автоматически изменяются по последнему явно прописанному значению.

## Функции модуля

### Функции для работы с базой данных

#### edb.init

Данная функция служит для инициализации базы данных.

Инициализация должна проводиться в самом начале игры, после чего больше повторяться не может. На всю игру создаётся только одна база данных. При этом инициализируются следующие значения в массиве `$EASY_DATABASE`:

* `ID` - идентификатор базы данных в виде псевдо-UUID. Нужен для проверки инициализации базы данных.
* `data_tables.counter` - счётчик созданных таблиц данных, включая удалённые.
* `data_tables.number` - счётчик существующих в настоящий момент таблиц данных.
* `data_tables.ids` - список существующих таблиц данных.
* `last_data_table` - указатель на предыдущую активную таблицу данных.
* `current_data_table` - указатель на текущую активную таблицу данных.

Вызов функции:

```qsp
@edb.init()
```

#### edb.print

Возвращает информацию по состоянию базы данных в человекочитаемом виде.

Аргументы:

* `$args[0]` — управляющие конструкции:
	* `[inmain]` — выведет информацию напрямую в окно основного описания.
	* `[instat]` — выведет информацию напрямую в окно дополнительного описания.
	* если ни одна из двух предыдущих конструкций не указана, вернёт информацию в виде результата.
	* `[all arrays]` — к информации добавится список всех массивов, занятых базой данных.

Примеры вызова функции:

```qsp
@edb.print('[instat] [all arrays]')
local $db_desc = @edb.print()
```

#### edb.new_table

Создаёт в базе данных новую таблицу данных.

Аргументы:

* `$args[0]` — обязательный аргумент, идентификатор таблицы данных.
* `$args[1]` — название таблицы данных. Можно не указывать, или указать пустое значение.
* `$args[2]` — тип первичных ключей (по умолчанию `[rstr:16]`):
	* `[msecscount]` - первичные ключи будут генерироваться на основе данных из функции msecscount.
	* `[uuid]` - первичные ключи генерируются в формате UUID
	* `[hex:N]` - первичные ключи генерируются, как порядковое шестнадцатерияное число из N символов. Это ограничит высоту таблицы данных максимальным возможным в этой таблице данных числом.
	* `[num:N]` - первичные ключи генерируются в виде N-значного десятеричного числа. Это ограничит высоту таблицы данных максимальным возможным в такой таблице числом.
	* `[rhex:N]` - первичным ключом будет назначаться случайное шестнадцатеричное число, состоящее из не менее, чем 8 символов.
	* `[rnum:N]` - первичным ключом будет назначаться случайное десятерично число, состоящее из не менее, чем 16 символов.
	* `[uid]` - первичный ключ будет генерироваться из строки случайных букв и цифр плюс текущее абсолютное значение от msecscount
	* `[rstr:N]` - первичный ключ генерируется, как случайный набор букв и цифр из N символов, но не менее 16 символов. 

При создании таблицы данных инициализируется массив, название которого совпадает с переданным идентификатором. При этом происходит инициализация следующих ячеек этого массива:

* `ID` — идентификатор таблицы данных.
* `NAME` — название таблицы данных.
* `columns` — список колонок таблицы данных.
* `current_col` — идентификатор текущей колонки (указатель).
* `current_row` — идентификатор текущей строки (указатель).
* `primary_keys_type` — тип первичных ключей.
* `free_keys` — список освободившихся первичных ключей (только для порядковых первичных ключей).

Также при создании таблицы данных изменяются соответствующие значения в `$EASY_DATABASE`, и инициализируется массив для колонки первичных ключей.

Примеры:

```qsp
@edb.new_table('objects', 'Предметы', '[rstr:32]')
@edb.new_table('dialogs', 'Диалоги и реплики', '[uuid]')
@edb.new_table('temp', '', '[msecscount]')
@edb.new_table('potions')
```

#### edb.del_table

Удаление указанной таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных.

При удалении таблицы данных уничтожаются массивы, соответствующие колонкам, а также одноимённый с идентификатором массив, описывающий свойства таблицы данных. Помимо этого изменяются соответствующие значения в массиве `$EASY_DATABASE`.

Примеры:

```qsp
! удаляем указанную таблицу данных:
@edb.del_table('dialogs')
! удаляем текущую таблицу данных:
@edb.del_table()
```


