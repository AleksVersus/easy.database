# Easy.DataBase

Система управления базой данных — это комплексный модуль (библиотека), предназначенный для простого редактирования нереляционной базы данных на QSP.

Существует модуль Олегуса, реализующий то же самое, но через другие механизмы: https://forum.ifiction.ru/viewtopic.php?id=1522.

## Подключение

"easy.database" подключается как любой другой модуль QSP, то есть с использованием команды `inclib`. Скачайте архив со [страницы релизов](https://github.com/AleksVersus/easy.nrBD/releases), распакуйте и скопируйте папку "`lib`" в папку с вашей игрой. Тогда на самой первой локации в игре достаточно будет прописать такую команду подключения:

```qsp
inclib 'lib/easy.database.qsp'
```

Для работы модуля требуется так же подключить и библиотеку "easy.math". Она поставляется вместе с модулем. Подключение аналогичное:

```qsp
inclib 'lib/easy.math.qsp'
```

Если вы уже используете библиотеку "easy.math" в своей игре, убедитесь, что версия "easy.math" совместима с "easy.database". Для этого в любом месте вашей игры используйте команду:

```qsp
*pl @edb.start('em-version')
```

При запуске игры вы увидите на экране текущую и необходимую версии модуля "easy.math".

### Работа с исходниками

Если вы пишете игру, используя Sublime Text с подключённым пакетом QSP, у вас есть возможность самостоятельно собирать модуль из исходников.

В папке "`[source]`" размещены исходные тексты модуля, а так же файл "`project.json`", отредактировав который вы наладите сборку модуля в папку с вашей игрой.

Так же вы можете собирать игру, напрямую включая в неё все локации модуля, если это необходимо. В этом случае вам не потребуется подключать модуль к игре — он уже будет в неё встроен.

В исходниках предусмотрены два режима сборки: без обработки препроцессором и с обработкой препроцессором.

В первом случае модуль будет собран, как есть, включая все служебные комментарии и наборы "предохранителей" — сообщений, которые всплывают в виде модальных окон и предупреждают о некоторых наиболее распространённых ошибках при работе с модулем. Данный режим сборки необходим на этапе разработки, отладки и тестирования игры.

Во втором случае необходимо включить препроцессор в "`project.json`", тогда из собранного модуля будут удалены все служебные комментарии, а так же блоки "предохранителей". Данный режим рекомендуется использовать при сборке релизной версии игры, когда большая часть ошибок уже отловлена.

Вы также можете включить препроцессор, но сохранить блоки предохранителей в конечной сборке модуля. Для этого в исходном файле "`00_edb.start.qsps`" в любом месте пропишите строку:

```qsp
!@pp:var(fuse)
```

**Обратите внимание!** Исходники библиотеки "easy.math" необходимо скачивать отдельно: [easy.math на github](https://github.com/AleksVersus/easy.math.3)

### Подключение встроенного отладчика

Вы можете подключить отладочные команды модуля к командной строке (полю ввода), прописав в самом начале игры следующую команду:

```qsp
$usercom[] = 'edb.usercom'
```

Это добавит новый обработчик строки ввода к уже работающим. Обратите внимание на квадратные скобки. Если вы используете свой собственный обработчик строки ввода и хотите, чтобы обработчик модуля работал совместно (параллельно) с вашим, обязательно ставьте квадратные скобки после `$usercom`.

Все команды модуля должны начинаться с ключевого слова `edb`. Для вывода списка всех доступных команд, введите в строке ввода `edb help`.

Также список всех доступных команд для поля ввода представлен в разделе данной документации "Команды отладки".

## Особенности работы

Технически база данных представляет собой наборы массивов, описывающих таблицы данных, а так же массивы, реализующие поведение колонок в таблицах данных. Основные свойства базы данных записываются в массив $EASY_DATABASE.

Поскольку все массивы, входящие в базу данных являются глобальными, недопустимо использовать их в других местах игры. Ввиду чего необходимо чётко понимать, какие имена будут заняты под базу данных. Эту информацию можно проверить, воспользовавшись функцией `edb.print`, или через встроенный отладчик, введя команду `edb >`.

При создании таблицы данных инициализируется массив, название которого совпадает с названием идентификатора таблицы данных, поэтому требования к такому идентификатору такие же, как и к названию массива, плюс идентификатор не должен начинаться с символа `$`.

Также при создании таблицы данных автоматически генерируется колонка первичных ключей. Она является служебной, и с ней нельзя напрямую взаимодействовать, хотя технически это такой же массив, как и все прочие, поэтому при желании вы можете изменять колонку первичных ключей, используя чистый QSP. Колонка первичных ключей всегда представляет собой массив, название которого состоит из идентификатора таблицы данных и слова '`_id`'.

Примеры имён массивов, представляющих колонки первичных ключей для разных таблиц данных:

```qsp
$objects_id
$dialogs_id
$potions_id
$temp_id
```

Основные функции, реализующие работу с базой данных, представленны в виде локаций-функций. Названия всех таких локаций начинаются с `edb`. Для удобства чтения кода названия локаций содержат точки, это не мешает использовать их при неявном вызове `func`:

```qsp
@edb.row.fill('Старый меч', 'сумка', 1, ($i, 'objects'))
```

Также для улучшения семантики в названиях локаций-функций указывается сущность, с которой они работают, и только затем непосредственно названия функций. Исключение составляют функции, работающие непосредственно с сущностью базы данных:

```qsp
@edb.init()
@edb.print('[all arrays]'')
```

Некоторые вспомогательные функции тоже не имеют в названии указания на сущность, с которой работают:

```qsp
@edb.gen_next_hex('0000ff', 6)
```

В базе данных работает система указателей, которые позволяют не писать каждый раз в каждой команде полностью, с какой строкой, колонкой и таблицей сейчас нужно работать. Указатели автоматически изменяются по последнему явно прописанному значению.

## Функции модуля

### Функции для работы с базой данных

Большинство функций автоматически перемещают указатель на указанные таблицу, колонку и/или строку.

#### edb.init

Данная функция служит для инициализации базы данных.

Инициализация должна проводиться в самом начале игры, после чего больше повторяться не может. На всю игру создаётся только одна база данных. При этом инициализируются следующие значения в массиве `$EASY_DATABASE`:

* `ID` - идентификатор базы данных в виде псевдо-UUID. Нужен для проверки инициализации базы данных.
* `data_tables.counter` - счётчик созданных таблиц данных, включая удалённые.
* `data_tables.number` - счётчик существующих в настоящий момент таблиц данных.
* `data_tables.ids` - список существующих таблиц данных.
* `last_data_table` - указатель на предыдущую активную таблицу данных.
* `current_data_table` - указатель на текущую активную таблицу данных.

Вызов функции:

```qsp
@edb.init()
```

#### edb.print

Возвращает информацию по состоянию базы данных в человекочитаемом виде.

Аргументы:

* `$args[0]` — управляющие конструкции:
	* `[inmain]` — выведет информацию напрямую в окно основного описания.
	* `[instat]` — выведет информацию напрямую в окно дополнительного описания.
	* если ни одна из двух предыдущих конструкций не указана, вернёт информацию в виде результата.
	* `[all arrays]` — к информации добавится список всех массивов, занятых базой данных.

Примеры вызова функции:

```qsp
@edb.print('[instat] [all arrays]')
local $db_desc = @edb.print()
```

#### edb.new_table

Создаёт в базе данных новую таблицу данных.

Аргументы:

* `$args[0]` — обязательный аргумент, идентификатор таблицы данных.
* `$args[1]` — название таблицы данных. Можно не указывать, или указать пустое значение.
* `$args[2]` — тип первичных ключей (по умолчанию `[rstr:16]`):
	* `[msecscount]` - первичные ключи будут генерироваться на основе данных из функции msecscount.
	* `[uuid]` - первичные ключи генерируются в формате UUID
	* `[hex:N]` - первичные ключи генерируются, как порядковое шестнадцатерияное число из N символов. Это ограничит высоту таблицы данных максимальным возможным в этой таблице данных числом.
	* `[num:N]` - первичные ключи генерируются в виде N-значного десятеричного числа. Это ограничит высоту таблицы данных максимальным возможным в такой таблице числом.
	* `[rhex:N]` - первичным ключом будет назначаться случайное шестнадцатеричное число, состоящее из не менее, чем 8 символов.
	* `[rnum:N]` - первичным ключом будет назначаться случайное десятерично число, состоящее из не менее, чем 16 символов.
	* `[uid]` - первичный ключ будет генерироваться из строки случайных букв и цифр плюс текущее абсолютное значение от msecscount
	* `[rstr:N]` - первичный ключ генерируется, как случайный набор букв и цифр из N символов, но не менее 16 символов. 

При создании таблицы данных инициализируется массив, название которого совпадает с переданным идентификатором. При этом происходит инициализация следующих ячеек этого массива:

* `ID` — идентификатор таблицы данных.
* `NAME` — название таблицы данных.
* `columns` — список колонок таблицы данных.
* `current_col` — идентификатор текущей колонки (указатель).
* `current_row` — идентификатор текущей строки (указатель).
* `primary_keys_type` — тип первичных ключей.
* `free_keys` — список освободившихся первичных ключей (только для порядковых первичных ключей).

Также при создании таблицы данных изменяются соответствующие значения в `$EASY_DATABASE`, и инициализируется массив для колонки первичных ключей.

Примеры:

```qsp
@edb.new_table('objects', 'Предметы', '[rstr:32]')
@edb.new_table('dialogs', 'Диалоги и реплики', '[uuid]')
@edb.new_table('temp', '', '[msecscount]')
@edb.new_table('potions')
```

#### edb.del_table

Удаление указанной таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных (по умолчанию используется идентификатор из указателя).

При удалении таблицы данных уничтожаются массивы, соответствующие колонкам, а также одноимённый с идентификатором массив, описывающий свойства таблицы данных. Помимо этого изменяются соответствующие значения в массиве `$EASY_DATABASE`.

Примеры:

```qsp
! удаляем указанную таблицу данных:
@edb.del_table('dialogs')
! удаляем текущую таблицу данных:
@edb.del_table()
```

#### edb.dt.set_cur

Устанавливает указанную таблицу данных текущей.

Аргументы:

* `$args[0]` — идентификатор таблицы данных.

Идентификатор текущей таблицы данных записывается в $EASY_DATABASE['last_data_table'], а идентификатор указанной таблицы данных записывается в $EASY_DATABASE['current_data_table'].

Пример:

```qsp
@edb.dt.set_cur('object')
```

#### edb.dt.print

Выводит на печать или возвращает человекочитаемое описание таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указывать, используется текущий.
* `$args[1]` — управление:
	* `[oi]`, `[only info]` — будет возвращена только информация о таблице данных
	* `[ot]`, `[only table]` — будет возвращёна только html-таблица с содержимым таблицы данных.
		* `[range:N-M]` — будут возвращены только строки с N по M включительно.
	* если предыдущие опции не указаны, возвращается и информация и html-таблица с содержимым.
	* `[inmain]` — выведет информацию напрямую в окно основного описания.
	* `[instat]` — выведет информацию напрямую в окно дополнительного описания.
	* если ни одна из двух предыдущих конструкций не указана, вернёт информацию в виде результата.

Примеры вызова:

```qsp
@edb.dt.print('objects', '[inmain]')
@edb.dt.print('objects', '[instat] [only info]')
@edb.dt.print('objects', '[ot] [range:2-4]')
```

**Внимание!!!** В описании таблицы данных указывается её высота, эта высота определяется размером массива первичных ключей, однако поскольку нулевая ячейка каждого массива используется под служебную информацию, полезная высота таблицы данных на единицу меньше обозначенной при выводе. Учитывайте это при работе с базой данных.

#### edb.dt.new_col

Создаёт колонку в таблице данных.

Аргументы:

* `$args[0]` — идентификатор колонки. Обязательный аргумент.
* `$args[1]` — тип колонки. По умолчанию, тип 'str'.
* `$args[2]` — идентификатор таблицы данных. Если не указан, используется текущий.

Примеры вызова:

```qsp
@edb.dt.new_col('body', 'dict', 'objects')
@edb.dt.new_col('place', 'str', 'objects')
@edb.dt.new_col('include')
@edb.dt.new_col('count', 'num')
```

При создании колонки в таблице данных инициализируется массив с именем, состоящим из идентификатора таблицы данных и идентификатора колонки данных, поэтому к идентификатору колонки применяются те же требования, что и к названиям массивов в QSP. Например, если идентификатор таблицы данных `objects`, а идентификатор колонки `body`, будет инициализирован массив `$objects_body`. При этом в нулевую ячейку такого массива записывается тип колонки:

* 'str' - это колонка, которая может содержать только простую строку
* 'dict' - это колонка, содержащая словарь значений. Словарь составляется из тегов типа "[tag:строка текста:tag]".
* 'list' - это строка, содержащая перечисленные через | значения
* 'tuple' - колонка со значениями кортежами
* 'num' - колонка с числовыми значениями
* 'ids' - колонка первичных ключей (нельзя указывать этот тип, так как колонка первичных ключей создаётся автоматически)

#### edb.dt.del_col

Удаляет колонку из таблицы данных.

Аргументы:

* `$args[0]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.dt.del_col('include', 'objects')
```

Удаление колонки приводит к уничтожению соответствующего массива. Восстановить удалённую колонку нельзя.

#### edb.dt.new_row

Создаёт строку в таблице данных, не заполняя её значениями.

Аргументы:

* `$args[0]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указтеля текущей колонки.

Функция возвращает идентификатор созданной строки, для дальнейшего использования.

В зависимости от установленного на этапе создания таблицы данных типа первичных ключей генерируется очередной первичный ключ для новой строки. Далее происходит заполнение всех массивов, соответствующих колонкам таблицы данных, пустыми значениями, при этом индексы заполняемых ячеек равны сгенерированному первичному ключу.

Пример:

```qsp
@edb.dt.new_row('objects')
local $r = @edb.dt.new_row('objects')
local $i = @edb.dt.new_row()
@edb.dt.new_row()
@edb.dt.new_row()
```

#### edb.dt.del_row

Удаляет из таблицы данных строку по указанному идентификатору. Если указан неверный идентификатор, функция просто не сработает.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Примеры:

```qsp
@edb.dt.del_row($r, 'objects')
@edb.dt.del_row($i)
```

Удаление строки — это уничтожение ячеек в массивах, соответствующих колонкам таблицы данных, по индексу, совпадающему с первичным ключом.

#### edb.dt.height

Функция для получения высоты таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Возвращает высоту таблицы данных (число).

**Внимание!!!** Высота таблицы данных определяется размером массива первичных ключей, однако поскольку нулевая ячейка каждого массива используется под служебную информацию, полезная высота таблицы данных на единицу меньше обозначенной при выводе. Учитывайте это при работе с базой данных.

Пример:

```qsp
@edb.dt.height('objects')
local height = @edb.dt.height()
```

#### edb.dt.width

Функция для получения ширины таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Возвращает ширину таблицы данных (число), которое соответствует числу колонок. Работа этой функции основана на цикле.

Пример:

```qsp
@edb.dt.width('objects')
local width = @edb.dt.width()
```

#### edb.dt.find

Поиск значения по таблице данных.

Аргументы:

* `$args[0]` - регулярное выражение по которому производится поиск. Поиск ведётся на точное совпадение с регулярным выражением. Невозможно производить поиск по регулярному выражению, если тип колонки, по которой производится поиск, 'num'.
* `$args[1]` - идентификатор колонки, по которой производится поиск. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы данных.
* `$args[3]` - размер чанка. Чанк - это фрагмент таблицы данных, по которому будет производиться поиск. Разбиение на чанки ускоряет поиск, если искомая информация находится где-то в начале таблицы данных.
* `$args[4]` ... `$args[18]` — дополнительные фильтры в виде кортежей:
	* (колонка, значение, управление) - управление:
		* `[regexp]` - регулярка. Точное соответствие. Не работает для колонок типа 'num'
		* `[callback]` - функция колбэк принимающая, как аргумент, значение элемента, и возвращающая 1 или 0, в зависимости от результатов фильтрации
		* `[strict]` (или не указанное значение) - проверяем на точное соответствие.

Функция возвращает идентификатор строки, в которой найдено искомое значение.

Примеры:

```qsp
local $row_id = @edb.dt.find('Старый (меч|щит|шлем)', 'body', 'objects', 10000, ('count', {result = iif(args[0]>1, 1, 0)}, '[callback]'))
$row_id@edb.dt.find('Старый')
```

#### edb.dt.clear

Очистка таблицы данных от всех данных. В результате работы функции все колонки в таблице данных сохраняются, но удаляются через удаление ячеек массивов все строки.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.dt.clear('objects')
```

#### edb.col.set_cur

Устанавливает указанную колонку в качестве текущей.

Аргументы:

* `$args[0]` — идентификатор колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Технически присваивает ячейке одноименного с идентификатором таблицы данных массива под индексом 'current_col' указанный идентификатор колонки.

Примеры:

```qsp
@edb.col.set_cur('body', 'objects')
@edb.col.set_cur('count')
```

#### edb.col.print

Вывод содержимого указанной колонки.

Аргументы:

* `$args[0]` — идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.
* `$args[2]` — управление:
	* `[inmain]` — выведет информацию напрямую в окно основного описания.
	* `[instat]` — выведет информацию напрямую в окно дополнительного описания.
	* если ни одна из двух предыдущих конструкций не указана, вернёт информацию в виде результата.
	* `[range:N-M]` — вывод значений от элемента N до M включительно в колонке.

Примеры:

```qsp
@edb.col.print('body', 'objects', '[inmain]')
@edb.col.print('count', 'objects', '[inmain] [range:3-5]')
```

#### edb.col.set_next

Присваивает значение ячейке текущей строки, затем перемещает указатель на следующую строку.

Аргументы:

* `$args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

**ВНИМАНИЕ!!!** Данная функция использует arrpos для поиска элементов. Для баз больших объёмов это может существенно подвешивать игру. Не используйте данную функцию без необходимости.

Примеры:

```qsp
@edb.col.set_next('Яблоко', 'name', 'objects')
@edb.col.set_next('Груша')
@edb.col.set_next('Старый меч')
```

#### edb.row.set_cur

Устанавливает указанную строку в качестве текущей.

Аргументы:

* `$args[0]` — идентификатор строки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Технически присваивает ячейке одноименного с идентификатором таблицы данных массива под индексом 'current_row' указанный идентификатор строки. Сделать текущей строку, которой нет в таблице данных нельзя, однако ошибку в игре это не вызовет.

Примеры:

```qsp
@edb.row.set_cur($r)
@edb.row.set_cur('000000f1')
```

#### edb.row.fill

Заполняет строку значениями.

Аргументы:

* `$args[0]` ... `$args[18]` — значения, или кортежи типа `(идентификатор колонки, значение)`, с помощью которых заполняются ячейки в строке.
* `$args[18]` ... `$args[0]` — кортеж типа `(идентификатор строки, идентификатор таблицы данных)`, либо только идентификатор строки.

**Внимание!** При использовании данной функции не происходит переключения текущей колонки.

Примеры:

```qsp
@edb.row.fill('Старый меч', 'сумка', 1, ($i, 'objects'))
@edb.row.fill('Старый шлем', 'сумка', 15, $n)
@edb.row.fill(('Пепел', 'body'), (2, 'count'), $s)
```

#### edb.row.print

Вывод содержимого указанной строки.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.
* `$args[2]` - управление:
	* `[inmain]` — выведет информацию напрямую в окно основного описания.
	* `[instat]` — выведет информацию напрямую в окно дополнительного описания.
	* если ни одна из двух предыдущих конструкций не указана, вернёт информацию в виде результата

Пример:

```qsp
@edb.row.print($i, 'objects', '[inmain]')
```

#### edb.row.set_next

Присваивает значение ячейке текущей колонки, затем перемещает указатель на следующую колонку.

* `$args[0]` - значение.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Примеры:

```qsp
@edb.row.set_next('Яблоко')
@edb.row.set_next('Инвентарь')
@edb.row.set_next(25)
```

#### edb.row.exchange

Функция меняет содержимое двух строк местами. **Внимание!!!** Меняется именно содержимое строк. Идентификаторы не перемещаются, т.е. фактически строки остаются на своих местах, но обмениваются **содержимым**!

* `$args[0]` - идентификатор одной строки.
* `$args[1]` - идентификатор другой строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Обменять ошибку несуществующих строк нельзя, однако ошибку в игре это не вызовет.

Строка, идентификатор которой передан в `$args[0]`, становится текущей.

Пример:

```qsp
@edb.row.exchange($d, $n, 'objects')
```

#### edb.row.extract

Извлекает из строки содержимое, помещая значения в указанный массив, при этом индексами элементов массива выступают названия колонок.

> Концепция функции взята из модуля Олегуса.

Аргументы:

* `$args[0]` - название массива. Обязательный аргумент.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.row.extract('septem', $i)
```

#### edb.row.inject

Функция вводит в указанную строку данные из указанного массива. При этом предполагается, что данные лежат в ячейках, индексы которых соответствуют названиям колонок таблицы данных.

**Внимание!!!** Новые данные затирают уже существующие в строке данные.

Аргументы:

* `$args[0]` - название массива. Обязательный аргумент.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.row.inject('septem', $n)
```

#### edb.cell.set_value

Устанавливает значение ячейки.

**Внимание!!!** Если в ячейке уже присутствует значение, оно будет затёрто новым.

Аргументы:

* `$args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.set_value('Инвентарь', $s, 'place', 'objects')
```

#### edb.cell.get_value

Возвращает значение ячейки.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.get_value($i, 'place', 'objects')
@edb.cell.get_value($s, 'place')
@edb.cell.get_value()
```

#### edb.cell.add

Прибавляет значение ячейке.

Данная функция по разному обрабатывает ячейки в колонках разных типов:

* 'num' — значение ячейки увеличивается на указанное число.
* 'str' — к значению ячейки приклеивается переданное значение (конкатенация).
* 'list' — добавляет к списку указанное значение.
* 'tuple' — увеличить число элементов в ячейке, в которой хранится кортеж, нельзя, однако можно изменить уже записанное в кортеж значение. В `$args[0]` при этом так же должен быть передан кортеж типа `($значение, #позиция)`.
* 'dict' — то же, что и 'str'.
* 'ids' — значения в колонке такого типа нельзя изменять через функции 'easy.database'.

Аргументы:

* `$args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.add(34, $d, 'count', 'objects')
@edb.cell.add('34')
```

#### edb.cell.del

Удаляет значение ячейки.

Данная функция по разному обрабатывает ячейки в колонках разных типов:

* 'num' — значение ячейки уменьшается на указанное число.
* 'str' — из значения ячейки удаляется первое вхождение переданного значения.
* 'list' — удаляет из списка указанное значение. Если значение повторяется в списке, будут удалены все.
* 'tuple' — уменьшить число элементов в ячейке, в которой хранится кортеж, нельзя, однако можно изменить уже записанное в кортеж значение. В `$args[0]` при этом должно быть передано либо значение, либо номер очищаемого элемента кортежа.
* 'dict' — то же, что и 'str'.
* 'ids' — значения в колонке такого типа нельзя изменять через функции 'easy.database'.

Аргументы:

* `$args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.del(34, $d, 'count', 'objects')
@edb.cell.del('body')
```
