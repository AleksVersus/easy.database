# Easy.DataBase

Система управления базой данных "easy.database" — это модуль (библиотека), предназначенный для простого редактирования нереляционной базы данных на QSP.

Существует модуль Олегуса, реализующий то же самое, но через другие механизмы: https://forum.ifiction.ru/viewtopic.php?id=1522.

Исходный код "easy.database" всегда доступен по адресу: https://github.com/AleksVersus/easy.database

## Подключение

"easy.database" подключается как любой другой модуль QSP, то есть с использованием команды `inclib`. Скачайте архив со [страницы релизов](https://github.com/AleksVersus/easy.database/releases), распакуйте и скопируйте папку "`lib`" в папку с вашей игрой. Тогда на самой первой локации в игре достаточно будет прописать такую команду подключения:

```qsp
inclib 'lib/easy.database.qsp'
```

Для работы модуля требуется также подключить и библиотеку "easy.math". Она поставляется вместе с модулем. Подключение аналогичное:

```qsp
inclib 'lib/easy.math.qsp'
```

Если вы уже используете библиотеку "easy.math" в своей игре, убедитесь, что версия "easy.math" совместима с "easy.database". Для этого в первой строчке первой локации вашей игры используйте команду:

```qsp
@edb.em.version()
```

При запуске игры вы увидите на экране сообщение с номерами текущей и необходимой версий модуля "easy.math".

### Работа с исходниками

Если вы пишете игру, используя Sublime Text с подключённым пакетом QSP, у вас есть возможность самостоятельно собирать модуль из исходников.

В папке "`[source]`" размещены исходные тексты модуля, а так же файл "`qsp-project.json`", отредактировав который? вы наладите сборку модуля в папку с вашей игрой.

Так же вы можете собирать игру, напрямую включая в неё все локации модуля, если это необходимо. В этом случае вам не потребуется подключать модуль к игре — он уже будет в неё встроен.

В исходниках предусмотрены два режима сборки: без обработки препроцессором и с обработкой препроцессором.

В первом случае модуль будет собран, как есть, включая все служебные комментарии и наборы "предохранителей" — сообщений, которые всплывают в виде модальных окон и предупреждают о некоторых наиболее распространённых ошибках при работе с модулем. Данный режим сборки необходим на этапе разработки, отладки и тестирования игры.

Во втором случае необходимо включить препроцессор в "`qsp-project.json`", тогда из собранного модуля будут удалены все служебные комментарии, а так же блоки "предохранителей". Данный режим рекомендуется использовать при сборке релизной версии игры, когда большая часть ошибок уже отловлена.

Вы также можете включить препроцессор, но сохранить блоки предохранителей в конечной сборке модуля. Для этого в исходном файле "`00_edb.start.qsps`" в любом месте пропишите строку:

```qsp
!@pp:var(edb_fuse)
```

> [!warning] **Обратите внимание!**
> Исходники библиотеки "easy.math" необходимо скачивать отдельно: [easy.math на github](https://github.com/AleksVersus/easy.math.3)

### Подключение встроенного отладчика

Вы можете подключить отладочные команды модуля к командной строке (полю ввода), прописав в самом начале игры следующую команду:

```qsp
@edb.usercom('on')
```

Это добавит новый обработчик строки ввода к уже работающим. 

Все команды модуля должны начинаться с ключевого слова `edb`. Для вывода списка всех доступных команд, введите в строке ввода `edb help`.

Также список всех доступных команд для поля ввода представлен в разделе данной документации ["Команды отладки"](#Команды%20отладки).

## Особенности работы

Технически база данных представляет собой наборы массивов, описывающих таблицы данных, а так же массивы, реализующие поведение колонок в таблицах данных. Основные свойства базы данных записываются в массив `$EASY_DATABASE`.

Поскольку все массивы, входящие в базу данных являются глобальными, недопустимо использовать их в других местах игры. Ввиду чего необходимо чётко понимать, какие имена будут заняты под базу данных. Эту информацию можно проверить, воспользовавшись функцией `edb.print`, или через встроенный отладчик, введя команду `edb >`.

При создании таблицы данных инициализируется массив, название которого совпадает с названием идентификатора таблицы данных, поэтому требования к такому идентификатору такие же, как и к названию массива, плюс идентификатор не должен начинаться с символа `$` или `%`.

Также при создании таблицы данных автоматически генерируется колонка первичных ключей. Она является служебной, и с ней нельзя напрямую взаимодействовать (за исключением некоторых случаев), хотя технически это такой же массив, как и все прочие.

> [!abstract] Технически: 
> Колонка первичных ключей всегда представляет собой массив, название которого состоит из идентификатора таблицы данных и слова '`_id`'.

Примеры имён массивов, представляющих колонки первичных ключей для разных таблиц данных:

```qsp
$objects_id
$dialogs_id
$potions_id
$temp_id
```

Основные функции, реализующие работу с базой данных, представленны в виде локаций-функций. Названия всех таких локаций начинаются с `edb`. Для удобства чтения кода названия локаций содержат точки, это не мешает использовать их при неявном вызове `func`:

```qsp
@edb.row.fill('Старый меч', 'сумка', 1, [$i, 'objects'])
```

Также для улучшения семантики в названиях локаций-функций указывается сущность, с которой они работают, и только затем непосредственно названия функций. Исключение составляют функции, работающие непосредственно с сущностью базы данных:

```qsp
@edb.init()
@edb.print('[all arrays]')
```

В базе данных работает система указателей, которые позволяют не писать в каждой команде полностью, с какой строкой, колонкой и таблицей сейчас нужно работать. Указатели автоматически изменяются по последнему явно прописанному значению.

## Сущности

В модуле реализована работа с некоторыми абстрактными сущностями, представляя которые легче работать с подобной псевдо-базой данных. В данном разделе приводится краткое описание этих сущностей, а так же общее описание функций для работы с ними. Можно представить, что такие функции являются неотъемлемым свойством указанных сущностей, поэтому эти функции в рамках руководства называются **методами**. Технически они методами не являются.

### База данных. Data Base

QSP не позволяет организовать полноценную базу данных, но в большинстве игр она и не нужна. Тем не менее можно реализовать некий аналог базы данных, чтобы облегчить себе работу с различными игровыми объектами.

Технически База данных в QSP — это набор массивов, которыми мы можем тем или иным образом управлять через специальные механизмы Системы Управления Базой Данных. Последнее воплощено в данном модуле.

Непосредственно База Данных, как сущность, представлена в виде глобального массива `$EASY_DATABASE[]`, в котором хранятся некоторые настройки, позволяющие Базой Данных управлять.

Чтобы использовать Базу Данных в своей игре, её необходимо инициализировать, то есть создать. А в дальнейшем применять методы для управления составляющими этой базы данных.

#### Методы

Методы Базы Данных представлены в виде соответствующих функций. С подробным описанием можно ознакомиться в разделе ["Функции модуля"](#).

* `init` - инициализация базы данных. Требуется в самом начале игры, чтобы заполнить массив `$EASY_DATABASE[]` исходными значениями. (`edb.init`).
* `print` — вывод на экран, или в виде возвращаемого результата, человекочитаемой информации о базе данных. (`edb.print`).
* `new_table` — создание таблицы данных с указанным идентификатором в базе данных. (`edb.new_table`).
* `del_table` — удаление таблицы данных с указанным идентификатором из базы данных. (`edb.del_table`).

#### Свойства

Свойства базы данных соответствуют значениям в массиве `$EASY_DATABASE`. См. функцию [`edb.init`](#).

### Таблица Данных. Data Table

Таблица данных — это наибольшая структурная единица базы данных. Именно из множества таблиц данных состоит вся база данных игры.

Технически Таблица Данных — это набор массивов, каждый из которых является столбцом такой таблицы. Соответственно строкой можно считать ряд записей во все массивы Таблицы Данных под одним индексом.

Непосредственно, как сущность, Таблица Данных представлена в виде массива, имя которого совпадает с названием идентификатора таблицы данных. В этом массиве хранятся некоторые настройки, позволяющие управлять таблицей данных.

#### Методы

Методы Таблицы Данных представлены в виде соответствующих функций. С подробным описанием можно ознакомиться в разделе ["Функции модуля"](#).

* `set_cur` - устанавливает указанную таблицу данных в качестве текущей. (`edb.dt.set_cur`).
* `print` - выводит на экран, или возвращает в виде результата, человекочитаемую информацию об указанной таблице данных. (`edb.dt.`).
* `new_col` - создаёт в таблице данных колонку с указанным идентификатором. (`edb.dt.new_col`).
* `del_col` - удаляет из таблицы данных колонку с указанным идентификатором. (`edb.dt.del_col`).
* `new_row` - создаёт в таблице данных строку и возвращает её идентификатор. (`edb.dt.new_row`).
* `del_row` - удаляет из таблицы данных строку с указанным идентификатором. (`edb.dt.del_row`).
* `height` - возвращает высоту таблицы данных, то есть число строк. (`edb.dt.height`).
* `width` - возвращает ширину таблицы данных, то есть число колонок. (`edb.dt.width`).
* `find` - возвращает идентификатор строки, в которой найдено указанное значение. Данный метод позволяет использовать дополнительные фильтры для более точного поиска информации в таблице данных. (`edb.dt.find`).
* `clear` - удаляет все строки в указанной таблице данных. (`edb.dt.clear`).
* `clone` - копирует таблицу данных, или её часть, в новую таблицу данных. (`edb.dt.clone`).

#### Свойства

Свойства таблицы данных соответствуют значениям в массиве, имя которого совпадает с идентификатором таблицы данных. См. функцию [`edb.new_table`](#edb.new_table). Помимо этого механизмы "easy.database" используют не обозначенные в данном массиве свойства:

* высота таблицы данных — определяется числом строк в таблице данных. Технически получается из размера массива, соответствующего колонке первичных ключей.
* ширина таблицы данных — число колонок в таблице данных.
* последний первичный ключ — индекс последней в таблице данных строки.

### Колонка. Column

Таблица данных разбивается на колонки для удобства размещения информации. Как правило, колонка используется для хранения неких однотипных данных, реализующих какое-либо свойство для хранимой записи. Например, в таблице предметов может быть создана отдельная колонка для хранения названия, отдельная — для хранения веса, для хранения количества, и так далее.

Технически колонка представляет собой массив, название которого состоит из идентификатора таблицы данных и идентификатора колонки, разделённых символом нижнего подчёркивания. В нулевой ячейке такого массива прописывается тип данных, которые можно хранить в колонке ([тип колонки](_fullguide/data_types.md)).

Примеры массивов, реализующих колонки:

* `$objects_sid` - колонка таблицы данных objects под именем sid.
* `$objects_body` - колонка таблицы данных objects под именем body

Колонки в данном руководстве могут называться столбцами.

#### Методы

* `set_cur` - устанавливает указанную колонку в качестве текущей. (`edb.col.set_cur`).
* `print` - выводит на экран, или возвращает в виде результата, содержимое колонки или части колонки. (`edb.col.print`).
* `set_next` - в указанной колонке присваивает значение ячейке текущей строки, затем перемещает указатель на следующую строку. (`edb.col.set_next`).

#### Свойства

У любой колонки есть всего два свойства:

* высота — совпадает с размером массива, описывающего колонку.
* [тип данных](_fullguide/data_types.md), хранящихся в колонке.

### Строка. Row

Таблица данных разбивается на отдельные записи — строки — для удобства размещения информации. Как правило, строка используется для хранения отдельных сложных записей. Например, в таблице предметов каждая отдельная запись соответствует одному предмету.

Технически строки в таблице данных представляют собой записи в ячейки всех массивов, описывающих столбцы, под одним (одинаковым) индексом.

Например, наша таблица данных `objects` состоит из трёх колонок `id`, `body`, `position`, это означает, что строки в такой таблице можно сформировать следующим образом:

```qsp
$objects_id['001']='001' & $objects_body['001']='Старый меч' & $objects_position['001']='loc1'
$objects_id['002']='002' & $objects_body['002']='Сумка для продуктов' & $objects_position['002']='hero:inventory'
$objects_id['003']='003' & $objects_body['003']='Яблоко' & $objects_position['003']='002'
```

#### Методы

* `set_cur` — устанавливает указанную строку в качестве текущей. (`edb.row.set_cur`).
* `fill` — заполняет строку группой значений. (`edb.row.fill`). Значения могут быть перечисленны по порядку в соответствующих аргументах (и таким образом будут размещены в колонках соответственно порядку идентификаторов колонок в списке колонок таблицы данных), либо в качестве аргументов можно указывать кортежи, состоящие из значения и идентификатора колонки. В последнем случае значения не обязательно передавать в порядке, соответствующем списку колонок. Если будут переданы одновременно аргументы в виде кортежей и отдельных значений, это может привести к ошибкам заполнения вроде перезаписи только что внесённых значений.
* `print` — выводит на экран, или возвращает в виде результата, содержимое строки, которое оформляется в виде списка. (`edb.row.print`). Данный метод подходит только для контроля содержимого строк со стороны разработчика, и его нельзя использовать для получения содержимого строки в механизмах игры, т.к. многие ячейки могут содержать в себе списки.
* `set_next` — присваивает ячейке (в текущей колонке и указнной строке) значение, а затем сдвигает указатель на следующую строку. Когда указатель достигает последнего столбца, он больше не сдвигается. Таким образом при постоянном обращении к этой функции происходит выход за пределы таблицы данных, а значит значение будет присваиваться всегда последней ячейке в строке.. (`edb.row.set_next`).
* `exchange` — обменивает содержимое строк, но сами строки позициями не меняются. Т.е. их идентификаторы в таблице данных не перемещаются. (`edb.row.exchange`).
* `extract` — извлекает из строки содержимое, помещая значения в указанный массив, при этом индексами элементов массива выступают названия колонок. (`edb.row.extract`).
* `inject` — вводит в указанную строку данные из указанного массива. При этом предполагается, что данные лежат в ячейках, индексы которых соответствуют названиям колонок таблицы данных. (`edb.row.inject`).
* `clone` — дублирует строку в таблице данных. То есть создаётся новая строка, идентичная указанной, но с отличающимся идентификатором. (`edb.row.clone`).

### Ячейка. Cell

Ячейка — наименьшая структурная единица таблицы данных. Ячейки создаются в пересечениях строк и столбцов.

Технически Ячейка Таблицы Данных представляет собой ячейку массива, соответствующего колонке, под указанным индексом, являющимся идентификатором строки. Каждая ячейка содержит лишь одно значение.

#### Методы

* `set_value` — устанавливает значение ячейки. Если в ячейке уже было значение, оно затирается. При этом не важно, какой тип имеет столбец, в ячейку технически записываются либо число (для столбцов типа 'num'), либо строка (для столбцов всех остальных типов). (`edb.cell.set_value`).
* `get_value` — извлекает значение из ячейки. (`edb.cell.get_value`).
* `add` — добавляет значение к значению ячейки. Результат работы данной функции будет отличаться в зависимости от типа колонки. (`edb.cell.add`).
* `del` — вычитает значение из значения ячейки. Результат работы данной функции будет отличаться в зависимости от типа колонки. (`edb.cell.del`).

### Список. List

Список — это сложное структурированное значение, позволяющее упаковать несколько значений в одну ячейку таблицы данных.

Технически список — это строка, состоящая из подстрок, разделённых вертикальной чертой. Это означает, что значения, хранящиеся в списке, не должны содержать символа вертикальной черты. Поэтому списки целесообразно использовать там, где вы точно знаете, какие данные будут в этот список помещены. Например, списки удобны для хранения перечня идентификаторов таблиц данных, или для хранения перечня колонок, и т.д.

Примеры списков:

```
aaaa|bbbb|....|zzzzz
AAA|BBB|CCC|AAA|BBB|DDD|EEE
sid|uid|body|position|include|charge|count|run
```

#### Методы

* `remove` - заменяет указанное значение в списке на новое значение. Позволяет заменить самое первое указанное значение в списке, либо сразу все значения в списке. (`edb.list.remove`).
* `is_el` - проверяет, является ли указанное значение элементом списка. (`edb.list.is_el`).
* `first` - получает первое значение в списке. (`edb.list.first`).
* `last` - получает последнее значение в списке. (`edb.list.last`).
* `append` - добавляет элемент в конец списка. (`edb.list.append`).
* `diff` - возвращает разницу двух списков. (`edb.list.diff`).
* `for_each` - перебирает элементы списка, и для каждого вызывает переданный в качестве аргумента код. В этот код нулевым аргументом передаётся значение элемента списка. Таким образом можно довольно гибко обрабатывать любые списки. (`edb.list.for_each`)
* `length` - возвращает длину списка. (`edb.list.length`).

#### Свойства

Единственным свойством списка является его длина.

## Функции модуля

### Функции для работы с базой данных

Большинство функций автоматически перемещают указатель на указанные таблицу, колонку и/или строку.

#### edb.init

Данная функция служит для инициализации базы данных.

Инициализация должна проводиться в самом начале игры, после чего больше повторяться не может. На всю игру создаётся только одна база данных. При этом инициализируются следующие значения в массиве `$EASY_DATABASE`:

* `ID` - идентификатор базы данных в виде псевдо-UUID. Нужен для проверки инициализации базы данных.
* `data_tables_counter` - счётчик созданных таблиц данных, включая удалённые.
* `data_tables_number` - счётчик существующих в настоящий момент таблиц данных.
* `data_tables_ids` - список существующих таблиц данных.
* `last_data_table` - указатель на предыдущую активную таблицу данных.
* `current_data_table` - указатель на текущую активную таблицу данных.

Вызов функции:

```qsp
@edb.init()
```

#### edb.print

Возвращает информацию по состоянию базы данных в человекочитаемом виде.

Аргументы:

* `$args[0]` — управляющие конструкции:
	* `[all arrays]` — к информации добавится список всех массивов, занятых базой данных.

Примеры вызова функции:

```qsp
@edb.print('[all arrays]')
local $db_desc = @edb.print()
```

#### edb.new_table

Создаёт в базе данных новую таблицу данных.

Аргументы:

* `$args[0]` — обязательный аргумент, идентификатор таблицы данных.
* `$args[1]` — название таблицы данных. Можно не указывать, или указать пустое значение. 

При создании таблицы данных инициализируется массив, название которого совпадает с переданным идентификатором. При этом происходит инициализация следующих ячеек этого массива:

* `ID` — идентификатор таблицы данных.
* `NAME` — название таблицы данных.
* `columns` — список колонок таблицы данных.
* `current_col` — идентификатор текущей колонки (указатель).
* `current_row` — идентификатор текущей строки (указатель).
* `primary_keys_type` — тип первичных ключей.

> [!note]- Примечание:
> Тип первичных ключей в текущей реализации всегда `[rstr:16]`.
>
> Было решено отказаться от произвольного выбора типа первичного ключа, поскольку это усложняет механизмы обработки таблицы данных.
> 
> Технически же первичным ключом может быть абсолютно любое строковое значение.

Также при создании таблицы данных изменяются соответствующие значения в `$EASY_DATABASE`, но массивы колонок не инициализируются.

Примеры:

```qsp
@edb.new_table('objects', 'Предметы')
@edb.new_table('dialogs', 'Диалоги и реплики')
@edb.new_table('temp', '')
@edb.new_table('potions')
```

#### edb.del_table

Удаление указанной таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных (по умолчанию используется идентификатор из указателя).

При удалении таблицы данных уничтожаются массивы, соответствующие колонкам, а также одноимённый с идентификатором массив, описывающий свойства таблицы данных. Помимо этого изменяются соответствующие значения в массиве `$EASY_DATABASE`.

Примеры:

```qsp
! удаляем указанную таблицу данных:
@edb.del_table('dialogs')
! удаляем текущую таблицу данных:
@edb.del_table()
```

#### edb.dt.set_cur

Устанавливает указанную таблицу данных текущей.

Аргументы:

* `$args[0]` — идентификатор таблицы данных.

Идентификатор текущей таблицы данных записывается в `$EASY_DATABASE['last_data_table']`, а идентификатор указанной таблицы данных записывается в `$EASY_DATABASE['current_data_table']`.

Пример:

```qsp
@edb.dt.set_cur('object')
```

#### edb.dt.print

Выводит на печать или возвращает человекочитаемое описание таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указывать, используется текущий.
* `$args[1]` — управление:
	* `[oi]`, `[only info]` — будет возвращена только информация о таблице данных
	* `[ot]`, `[only table]` — будет возвращёна только html-таблица с содержимым таблицы данных.
		* `[range:N-M]` — будут возвращены только строки с N по M включительно.
	* если предыдущие опции не указаны, возвращается и информация и html-таблица с содержимым.

Примеры вызова:

```qsp
@edb.dt.print('objects')
@edb.dt.print('objects', '[only info]')
@edb.dt.print('objects', '[ot] [range:2-4]')
```

#### edb.dt.new_col

Создаёт колонку в таблице данных.

Аргументы:

* `$args[0]` — идентификатор колонки. Обязательный аргумент.
* `$args[1]` — тип колонки. По умолчанию, тип '`str`'.
* `$args[2]` — идентификатор таблицы данных. Если не указан, используется текущий.

Примеры вызова:

```qsp
@edb.dt.new_col('body', 'dict', 'objects')
@edb.dt.new_col('place', 'str', 'objects')
@edb.dt.new_col('include')
@edb.dt.new_col('count', 'num')
```

При создании колонки в таблице данных инициализируется массив с именем, состоящим из идентификатора таблицы данных и идентификатора колонки данных, поэтому к идентификатору колонки применяются те же требования, что и к названиям массивов в QSP. Например, если идентификатор таблицы данных `objects`, а идентификатор колонки `body`, будет инициализирован массив `$objects_body`.

При создании колонки, [её тип](_fullguide/data_types.md) записывается в массив таблицы данных в ячейку с текстовым индексом `column.COLUMN_ID.type`, где `COLUMN_ID` — идентификатор колонки.

#### edb.dt.del_col

Удаляет колонку из таблицы данных.

Аргументы:

* `$args[0]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.dt.del_col('include', 'objects')
```

Удаление колонки приводит к уничтожению соответствующего массива, а так же к удалению ячейки массива, описывающего таблицу данных, с индексом `column.COL_ID.type`, где `COL_ID` — идентификатор колонки. Восстановить удалённую колонку нельзя.

#### edb.dt.new_row

Создаёт строку в таблице данных, не заполняя её значениями.

Аргументы:

* `$args[0]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указтеля текущей колонки.

Функция возвращает идентификатор созданной строки, для дальнейшего использования.

Генерируется первичный ключ, а затем происходит заполнение всех массивов, соответствующих колонкам таблицы данных, пустыми значениями, при этом индексы заполняемых ячеек равны сгенерированному первичному ключу.

Пример:

```qsp
@edb.dt.new_row('objects')
local $r = @edb.dt.new_row('objects')
local $i = @edb.dt.new_row()
@edb.dt.new_row()
@edb.dt.new_row()
```

#### edb.dt.del_row

Удаляет из таблицы данных строку по указанному идентификатору. Если указан неверный идентификатор, функция просто не сработает.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Примеры:

```qsp
@edb.dt.del_row($r, 'objects')
@edb.dt.del_row($i)
```

Удаление строки — это уничтожение ячеек в массивах, соответствующих колонкам таблицы данных, по индексу, совпадающему с первичным ключом.

#### edb.dt.height

Функция для получения высоты таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Возвращает высоту таблицы данных (число).

Пример:

```qsp
@edb.dt.height('objects')
local height = @edb.dt.height()
```

#### edb.dt.width

Функция для получения ширины таблицы данных.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Возвращает ширину таблицы данных (число), которое соответствует числу колонок. Работа этой функции основана на цикле.

Пример:

```qsp
@edb.dt.width('objects')
local width = @edb.dt.width()
```

#### edb.dt.find

Поиск значения по таблице данных.

Аргументы:

* `$args[0]` - регулярное выражение по которому производится поиск. Поиск ведётся на точное совпадение с регулярным выражением. Невозможно производить поиск по регулярному выражению, если тип колонки, по которой производится поиск, 'num' или 'tuple'.
* `$args[1]` - идентификатор колонки, по которой производится поиск. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы данных.
* `args[3]` - размер чанка. Чанк - это фрагмент таблицы данных, по которому будет производиться поиск. Разбиение на чанки ускоряет поиск, если искомая информация находится где-то в начале таблицы данных.
* `%args[4]` ... `%args[18]` — дополнительные фильтры в виде кортежей:
	* (колонка, значение, управление) - управление:
		* `[regexp]` - регулярка. Точное соответствие. Не работает для колонок типа 'num' и 'tuple'
		* `[callback]` - функция колбэк принимающая, как аргумент, значение элемента, и возвращающая 1 или 0, в зависимости от результатов фильтрации
		* `[strict]` (или не указанное значение) - проверяем на точное соответствие.

Функция возвращает идентификатор строки, в которой найдено искомое значение.

Примеры:

```qsp
local $row_id = @edb.dt.find('Старый (меч|щит|шлем)', 'body', 'objects', 10000, ('count', {result = iif(args[0]>1, 1, 0)}, '[callback]'))
$row_id = @edb.dt.find('Старый')
```

#### edb.dt.clear

Очистка таблицы данных от всех данных. В результате работы функции все колонки в таблице данных сохраняются, но удаляются через удаление ячеек массивов все строки.

Аргументы:

* `$args[0]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Пример:
> 
> ```qsp
> @edb.dt.clear('objects')
> ```

#### edb.dt.clone

Создаёт копию таблицы данных, или указанной части таблицы данных.

Аргументы:

* `$args[0]` - идентификатор новой таблицы данных. Обязательный аргумент.
* `$args[1]` - идентификатор исходной таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.
* `$args[2]` или `args[2]` - идентификатор строки, от которой нужно производить клонирование, или номер этой строки. Если не указано, копирование таблицы данных будет производиться с первой строки. Технически нумерация ячеек массива начинается с нуля.
* `args[3]` - число строк, которые необходимо скопировать. По умолчанию: все оставшиеся строки.

Технически функция делает то, что указано. Создаёт точную копию уже существующей таблицы данных, либо некоторого количества её строк. При этом копируются все колонки, в т.ч. и колонка первичных ключей. В новой таблице данных снимаются все указатели, однако указатель текущей таблицы данных переводится на неё.

> [!example] Примеры:
> 
> ```qsp
> ! копируем таблицу полностью
> @edb.dt.clone('new_objs', 'objects')
> ! копируем несколько строк в новую таблицу данных
> @edb.dt.clone('find_objs', 'objects', '000005', 6)
> ```

#### edb.col.set_cur

Устанавливает указанную колонку в качестве текущей.

Аргументы:

* `$args[0]` — идентификатор колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Технически присваивает ячейке одноименного с идентификатором таблицы данных массива под индексом 'current_col' указанный идентификатор колонки.

> [!example] Примеры:
> 
> ```qsp
> @edb.col.set_cur('body', 'objects')
> @edb.col.set_cur('count')
> ```

#### edb.col.print

Вывод содержимого указанной колонки.

Аргументы:

* `$args[0]` — идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.
* `$args[2]` — управление:
	* `[range:N-M]` — вывод значений от элемента N до M включительно в колонке.

> [!example] Примеры:
> 
> ```qsp
> @edb.col.print('body', 'objects')
> @edb.col.print('count', 'objects', '[range:3-5]')
> ```

#### edb.col.set_next

Присваивает значение ячейке текущей строки, затем перемещает указатель на следующую строку.

Аргументы:

* `$args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!warning] **ВНИМАНИЕ!!!** 
> Данная функция использует `arrpos` для поиска элементов. Для баз больших объёмов это может существенно подвешивать игру. Не используйте данную функцию без необходимости.

> [!example] Примеры:
> 
> ```qsp
> @edb.col.set_next('Яблоко', 'name', 'objects')
> @edb.col.set_next('Груша')
> @edb.col.set_next('Старый меч')
> ```

#### edb.row.set_cur

Устанавливает указанную строку в качестве текущей.

Аргументы:

* `$args[0]` — идентификатор строки.
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Технически присваивает ячейке одноименного с идентификатором таблицы данных массива под индексом 'current_row' указанный идентификатор строки. Сделать текущей строку, которой нет в таблице данных нельзя, однако ошибку в игре это не вызовет.

> [!example] Примеры:
> 
> ```qsp
> @edb.row.set_cur($r)
> @edb.row.set_cur('000000f1')
> ```

#### edb.row.fill

Заполняет строку значениями.

Аргументы:
 
* `%args[0]`  — кортеж значений, помещаемых подряд в колонки, или кортеж типа `[идентификатор колонки, значение]`.
* `%args[1]` ... `%args[18]` — кортежи типа `[идентификатор колонки, значение]`.

> [!warning] **Внимание!**
> Перед использованием функции должны быть выставлены указатели текущей таблицы данных и строки, иначе функция работать не будет.
> При использовании данной функции не происходит переключения текущей колонки.

> [!example] Примеры:
>
> ```qsp
> @edb.dt.set_cur('objects')
> @edb.row.set_cur($row_id)
> 
> @edb.row.fill(['Старый меч', 'сумка', 1])
> @edb.row.fill(['Старый шлем', 'сумка', 15], ['includes', '<<$sword_id>>|<<$shield_id>>'])
> @edb.row.fill(['body', 'Пепел'], ['count', 2], ['types', ['steel', 'arms']])
> ```

#### edb.row.print

Вывод содержимого указанной строки.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Пример:
> 
> ```qsp
> @edb.row.print($i, 'objects')
> ```

#### edb.row.set_next

Присваивает значение ячейке текущей колонки, затем перемещает указатель на следующую колонку.

* `$args[0]` - значение.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Примеры:
> 
> ```qsp
> @edb.row.set_next('Яблоко')
> @edb.row.set_next('Инвентарь')
> @edb.row.set_next(25)
> ```

#### edb.row.exchange

Функция меняет содержимое двух строк местами.

> [!warning] **Внимание!!!**
> Меняется именно содержимое строк. Идентификаторы не перемещаются, т.е. фактически строки остаются на своих местах, но обмениваются **содержимым**!

* `$args[0]` - идентификатор одной строки.
* `$args[1]` - идентификатор другой строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Обменять содержимое несуществующих строк нельзя, однако ошибку в игре это не вызовет.

Строка, идентификатор которой передан в `$args[0]`, становится текущей.

> [!example] Пример:
> 
> ```qsp
> @edb.row.exchange($d, $n, 'objects')
> ```

#### edb.row.extract

Извлекает из строки содержимое, помещая значения в указанный массив, при этом индексами элементов массива выступают названия колонок.

> [!tip] Примечание:
> Концепция функции взята из модуля Олегуса.

Аргументы:

* `$args[0]` - название массива. Обязательный аргумент.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Пример:
> 
> ```qsp
> @edb.row.extract('septem', $i)
> ```

#### edb.row.inject

Функция вводит в указанную строку данные из указанного массива. При этом предполагается, что данные лежат в ячейках, индексы которых соответствуют названиям колонок таблицы данных.

> [!warning] **Внимание!!!**
> Новые данные затирают уже существующие в строке данные.

Аргументы:

* `$args[0]` - название массива. Обязательный аргумент.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Пример:
> 
> ```qsp
> @edb.row.inject('septem', $n)
> ```

#### edb.row.clone

Копирует строку внутри таблицы данных.

Аргументы:

* `$args[0]` — идентификатор клонируемой строки. Если не указан, клонируется текущая строка (идентификатор которой находится в указателе текущей строки).
* `$args[1]` — идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.
* `$args[2]` — требуемый идентификатор новой строки.
  
  > [!warning] ВНИМАНИЕ!!!
  > При использовании этой опции не учитывается дублирование первичных ключей. Используйте только когда уверены, что первичные ключи не будут дублированы.

Возвращает идентификатор новой строки.

Технически в таблице данных создаётся новая строка с новым первичным ключом. Все остальные значения в ячейках этой строки идентичны значениям в исходной строке.

> [!example] Пример:
> 
> ```qsp
> $new_string_ = @edb.row.clone($i, 'objects')
> ```

#### edb.cell.set_value

Устанавливает значение ячейки.

> [!warning] **Внимание!!!**
> Если в ячейке уже присутствует значение, оно будет затёрто новым.

Аргументы:

* `$args[0]`, `%args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

> [!example] Пример:
> 
> ```qsp
> @edb.cell.set_value('Инвентарь', $s, 'place', 'objects')
> ```

#### edb.cell.get_value

Возвращает значение ячейки.

Аргументы:

* `$args[0]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[1]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[2]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.get_value($i, 'place', 'objects')
@edb.cell.get_value($s, 'place')
@edb.cell.get_value()
```

#### edb.cell.add

Прибавляет значение ячейке.

Данная функция по разному обрабатывает ячейки в колонках разных типов:

* `'num'` — значение ячейки увеличивается на указанное число.
* `'str'` — к значению ячейки приклеивается переданное значение (конкатенация).
* `'list'` — добавляет к списку указанное значение.
* `'tuple'` — увеличить число элементов в ячейке, в которой хранится кортеж, нельзя, однако можно изменить уже записанное в кортеж значение. В `$args[0]` при этом так же должен быть передан кортеж типа `[$значение, #позиция]`.
* `'dict'` — то же, что и `'str'`.
* `'code'` - подобно `dict`
* `'ids'` — значения в колонке такого типа нельзя изменять через функции 'easy.database'.

Аргументы:

* `$args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.add(34, $d, 'count', 'objects')
@edb.cell.add('34')
```

#### edb.cell.del

Удаляет значение ячейки.

Данная функция по разному обрабатывает ячейки в колонках разных типов:

* `'num'` — значение ячейки уменьшается на указанное число.
* `'str'` — из значения ячейки удаляется первое вхождение переданного значения.
* `'list'` — удаляет из списка указанное значение. Если значение повторяется в списке, будут удалены все.
* `'tuple'` — уменьшить число элементов в ячейке, в которой хранится кортеж, нельзя, однако можно изменить уже записанное в кортеж значение. В `$args[0]` при этом должно быть передано либо значение, либо номер очищаемого элемента кортежа.
* `'dict'` — то же, что и `'str'`.
* `'code'` — удалить код напрямую нельзя.
* `'ids'` — значения в колонке такого типа нельзя изменять через функции 'easy.database'.

Аргументы:

* `$args[0]` или `args[0]` - значение, присваиваемое ячейке.
* `$args[1]` - идентификатор строки. Если не указан, используется идентификатор из указателя текущей строки.
* `$args[2]` - идентификатор колонки. Если не указан, используется идентификатор из указателя текущей колонки.
* `$args[3]` - идентификатор таблицы данных. Если не указан, используется идентификатор из указателя текущей таблицы.

Пример:

```qsp
@edb.cell.del(34, $d, 'count', 'objects')
@edb.cell.del('body')
```

### Вспомогательные функции

#### edb.key.next_hex

Вспомогательная функция для генерации следующего порядкового номера в виде шестнадцатеричного ключа.

Аргументы (обязательные):

* `$args[0]` - последний сгенерированный ключ.
* `args[1]` - необходимая длина ключа.

Возвращает шестнадцатеричный ключ следующий за указанным по порядку, либо, если длина сгенерированного ключа превышает необходимую, возвращает нулевой ключ. Длина ключа всегда соответствует необходимой длине.

Примеры:

```qsp
@edb.key.next_hex('0', 8)			& ! '00000001'
@edb.key.next_hex('00055', 8)		& ! '00000056'
@edb.key.next_hex('0ff', 8)			& ! '00000100'
@edb.key.next_hex('ffffffff', 8)	& ! '00000000'
@edb.key.next_hex('fffffffd', 8)	& ! 'fffffffe'
```

#### edb.key.next_num

Вспомогательная функция для генерации следующего порядкового номера в виде десятеричного ключа.

Аргументы (обязательные):

* `$args[0]` - последний сгенерированный ключ.
* `args[1]` - необходимая длина ключа.

Возвращает десятеричный ключ следующий за указанным по порядку, либо, если длина сгенерированного ключа превышает необходимую, возвращает нулевой ключ. Длина ключа всегда соответствует необходимой длине.

Примеры:

```qsp
@edb.key.next_num('0', 8)			& ! '00000001'
@edb.key.next_num('00055', 8)		& ! '00000056'
@edb.key.next_num('0ff', 8)			& ! '00000001'
@edb.key.next_num('ffffffff', 8)	& ! '00000001'
@edb.key.next_num('99999999', 8)	& ! '00000000'
@edb.key.next_num('99999994', 8)	& ! '99999995'
```

#### edb.list.remove

Заменяет в списке первое вхождение, или все вхождения, указанного значения на новое значение, если указанное значение присутствует в списке.

Аргументы:

* `$args[0]` - Список вида `aaaa|bbbb|....|zzzzz`. Обязательный аргумент.
* `$args[1]` - старое значение.
* `$args[2]` - новое начение. Если не указано, элемент удаляется из списка.
* `$args[3]` - разделитель. Если не указано: вертикальная черта `|`.
* `$args[4]` - управление:
	* `[nclr]` или `[no clear]` - пустые значения между разделителями не удаляются.
	* `[of]` или `[only first]` - заменяется только первое вхождение указанного значения.

Возвращает видоизменённый список.

Примеры:

```qsp
@edb.list.remove('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA')
!                    'BBB|CCC|BBB|DDD|EEE'
@edb.list.remove('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA', 'aaa')
!                'aaa|BBB|CCC|aaa|BBB|DDD|EEE'
@edb.list.remove('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA', '', '|', '[no clear]')
!                   '|BBB|CCC||BBB|DDD|EEE'
@edb.list.remove('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA', '', '|', '[only first]')
!                    'BBB|CCC|AAA|BBB|DDD|EEE'
```

#### edb.list.is_el

Проверяет наличие указанного элемента в списке.

Аргументы:

* `$args[0]` - Список вида `aaaa|bbbb|....|zzzzz`. Обязательный аргумент.
* `$args[1]` - элемент, искомое значение. Обязательный аргумент.
* `$args[2]` - разделитель. Если не указано: вертикальная черта `|`.

Возвращает единицу, если элемент в списке присутствует. Если элемента в списке нет, возвращает 0.

Примеры:

```qsp
@edb.list.is_el('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA') & ! 1
@edb.list.is_el('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'BBB') & ! 1
@edb.list.is_el('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'FFF') & ! 0
@edb.list.is_el('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'EEE') & ! 1
```

#### edb.list.first

Извлекает из списка первый элемент. Преимущество перед `em.str.getWord` в том, что функция не использует цикл.

* `$args[0]` - Список вида `aaaa|bbbb|....|zzzzz`. Обязательный аргумент.
* `$args[1]` - разделитель. Если не указано: вертикальная черта `|`.

Возвращает значение элемента до первого разделителя. Если разделителя в списке нет, возвращает исходное значение.

```qsp
@edb.list.first('id|body|count|place|include')	& ! 'id'
@edb.list.first('body|count|place|include')		& ! 'body'
@edb.list.first('count|place|include')			& ! 'count'
@edb.list.first('place|include')				& ! 'place'
@edb.list.first('include')						& ! 'include'
```

#### edb.list.last

Извлекает из списка последний элемент. Преимущество перед `em.str.getWord` в том, что функция не использует цикл.

* `$args[0]` - Список вида `aaaa|bbbb|....|zzzzz`. Обязательный аргумент.
* `$args[1]` - разделитель. Если не указано: вертикальная черта `|`.

Возвращает значение элемента после последнего разделителя. Если разделителя в списке нет, возвращает исходное значение.

```qsp
@edb.list.last('id|body|count|place|include')	& ! 'include'
@edb.list.last('body|count|place|include')		& ! 'include'
@edb.list.last('count|place|include')			& ! 'include'
@edb.list.last('place|include')					& ! 'include'
@edb.list.last('include')						& ! 'include'
```

#### edb.list.append

Добавляет новый элемент в конец списка.

* `$args[0]` - Список вида `aaaa|bbbb|....|zzzzz`. Обязательный аргумент.
* `$args[1]` - элемент, добавляемое значение. Обязательный аргумент.
* `$args[2]` - разделитель. Если не указано: вертикальная черта `|`.

Возвращает новый список с добавленным элементом, либо, если исходный список пуст, возвращает указанный элемент.

```qsp
@edb.list.append('', 'id')							& ! 'id'
@edb.list.append('id', 'body')						& ! 'id|body'
@edb.list.append('id|body', 'count')				& ! 'id|body|count'
@edb.list.append('id|body|count', 'place')			& ! 'id|body|count|place'
@edb.list.append('id|body|count|place', 'include')	& ! 'id|body|count|place|include'
```

#### edb.list.diff

Функция получения разницы между двумя списками.

* `$args[0]` - уменьшаемый список вида `aaaa|bbbb|....|zzzzz`.
* `$args[1]` - вычитаемый список вида `aaaa|bbbb|....|zzzzz`.
* `$args[2]` - разделитель. Если не указано: вертикальная черта `|`.
* `$args[3]` - управление:
	* `[union]` или `[un]` - в этом режиме из обоих списков исключаются совпадающие значения, а все оставшиеся возвращаются в виде нового списка.

Возвращает новый список.

**Внимание!!!** Удаляется только первое совпадение в списке. Ввиду того, что функция не используется в модуле, она не доработана. Вы можете самостоятельно написать похожую функцию, используя иные функции работы со списками.

Примеры:

```qsp
@edb.list.diff('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA|BBB|CCC')					 & ! 'AAA|BBB|DDD|EEE'
@edb.list.diff('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA|DDD|EEE')					 & ! 'BBB|CCC|AAA|BBB'
@edb.list.diff('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'JJJ|FFF|GGG')					 & ! 'AAA|BBB|CCC|AAA|BBB|DDD|EEE'
@edb.list.diff('AAA|BBB|CCC|AAA|BBB|DDD|EEE', 'AAA|FFF|GGG|EEE', '|', '[union]') & ! 'BBB|CCC|AAA|BBB|DDD|FFF|GGG'
```

#### edb.list.for_each

Функция перебора элементов списка с вызовом функции, переданной в виде текстового значения.

* `$args[0]` - список вида `aaaa|bbbb|....|zzzzz`.
* `$args[1]` - функция, применяющаяся к каждому элементу списка (условный колбэк).
* `$args[2]` - разделитель. Если не указано: вертикальная черта `|`.
* `$args[3]` ... `$args[18]` - аргументы, транслируемые в функцию-колбэк.

Данная функция циклически перебирает все элементы списка, вызывая переданную в виде текстового значения функцию (условный колбэк) через `$dyneval`. При этом в `$dyneval` в нулевом аргументе передаётся значение - элемент списка, а во все остальные аргументы транслируются значения из аргументов с 3-его по 18-ый. Это позволяет использовать переданную в виде текстового значения функцию, как колбэк, и таким образом гибко обрабатывать элементы списка.

`edb.list.for_each` может возвращать текстовое (только текстовое!) значение, получаемое путём склейки (конкатенация) полученных из колбэка значений. Если колбэк не возвращает никаких значений, `edb.list.for_each` так же ничего не вернёт.

Все аргументы, принимаемые колбэком, должны передаваться в текстовом виде, поэтому если вам нужно передать в колбэк число, сначала преобразуйте его в строковое значение. В колбэке строку снова можно преобразовать в число.

В колбэк всегда предаётся 16 аргументов от `$args[0]` до `$args[15]`, учитывайте это при оформлении колбэка. Соответствие аргументов, переданных в `edb.list.for_each`, аргументам в колбэке:

* `$args[0]` - значение, элемент списка,
* `$args[1] = $args[3]`
* `$args[2] = $args[4]`
* `$args[3] = $args[5]`
* `$args[4] = $args[6]`
* и т.д.

Примеры:

```qsp

$list_ = 'AAA|BBB|CCC|AAA|BBB|DDD|EEE'

! склейка значений списка, с исключением 'AAA':

$callback_ = { $result = iif($args[0] = 'AAA', '', $args[0]) }

*pl @edb.list.for_each($list_, $callback_)

! 'BBBCCCBBBDDDEEE'

! подсчёт числа элементов списка

$callback_ = { $result = '0' }
*pl len(@edb.list.for_each($list_, $callback_))

! 7

! реверс элементов списка

local $reverse_ = ''
$callback_ = { $reverse_ = '|' + $args[0] + $reverse_ }
@edb.list.for_each($list_, $callback_)
*pl $mid($reverse_, 2)

! 'EEE|DDD|BBB|AAA|CCC|BBB|AAA'
```

#### edb.list.length

Возвращает число элементов в списке. Использует цикл.

Аргументы:

* `$args[0]` - список вида `aaaa|bbbb|....|zzzzz`.
* `$args[1]` - разделитель. Если не указано: вертикальная черта `|`.

Пример:

```qsp
@edb.list.length('AAA|BBB|CCC|AAA|BBB|DDD|EEE') & ! 7
```

## Команды отладки

**Внимание!!!** Отладчик ещё не доработан. Команды могут отличаться от версии к версии. Если вы вводите команду, а она не работает, или работает некорректно, проверьте локацию `edb.usercom`, чтобы убедиться, что ваша версия модуля поддерживает данную команду.

Все команды отладки начинаются с ключевого слова `edb`. Без этого ключевого слова отладчик просто не сработает. Ниже команды отладки приводятся без этого ключевого слова. Пример правильно введённой команды к отладчику:

```cmd
edb help
```

* `help` - вывод справки по модулю `easy.database`.
* `run` - выполнить следующий после `run` текст, как строку кода QSP.
* `verison` — текущая версия модуля.
* `required em` — информация по используемому и необходимому easy.math.
* `gen id` - генерирует uuid.
* `init` - инициализирует базу данных.
* `>` - выводит информацию о базе данных.

Последняя команда может быть расширена через доп инструкции, идентификаторы сущностей и инструкции к ним. Большинство инструкций к сущностям совпадают с названиями методов для этих сущностей. Однако не все методы можно использовать. Ниже приводится список, соответствующий расширениям команды. Идентификаторы сущностей и инструкций должны разделяться символом `>`. Пример:

```cmd
edb > objects > body > 000005 > get_value
```

* `new_table` - создать новую таблицу данных. Идентификатор указывается далее через `>`.
* `del_table` - удалить таблицу данных. Идентификатор указывается далее через `>`.
* **идентификатор таблицы данных** - работа с указанной таблицей данных. Через `>` указывается:
	* `set_cur` — установить таблицу данных текущей.
	* `print` - распечатать информацию по таблице данных в основном описании.
	* `new_col` - создать новую колонку в таблице данных. Идентификатор колонки указывается далее через `>`.
	* `del_col` - удалить колонку из таблицы данных. Идентификатор колонки указывается далее через `>`.
	* `new_row` - создать новую строку в таблице данных. Идентификатор строки указывается далее через `>`.
	* `del_row` - удалить строку из таблицы данных. Идентификатор строки указывается далее через `>`.
	* `height` - получить высоту таблицы данных.
	* `width` - получить ширину таблицы данных.
	* `clear` - очистить таблицу данных от строк.
	* `clone` - полное клонирование таблицы данных в новую таблицу данных. Идентификатор новой таблицы данных указывается далее через `>`.
	* **идентификатор строки** - работа с указанной строкой в таблице данных. Через `>` указывается:
		* `set_cur` — установить строку текущей.
		* `print` — вывести на экран содержимое строки в виде списка.
	* **идентификатор колонки** - работа с указанной колонкой в таблице данных. Через `>` указывается:
		* `set_cur` — установить колонку текущей.
		* `print` — вывести на экран содержимое колонки.
		**идентификатор строки** - работа с ячейкой в указанных колонке и строке. Через `>` указывается:
			* `set_value` - установить значение ячейки. Значение указывается через `>` без пробелов. Все последующие символы `>` считаются относящимися к значению.
			* `get_value` - вывести на экран значение ячейки. Значение можно сразу записать в глобальную переменную, для этого через `>` указывается название переменной.

## История версий

### easy.database v.0.1

* Разработана концепция и структура Системы Управления Базой Данных.
* Добавлены основные функции и свёрстана документация.

### easy.database v.0.2

* Небольшой рефакторинг кода и документации.
* Добавлены функции `edb.row.clone`, `edb.dt.clone`.
* Расширен функционал `edb.list.remove` - теперь может удалять первое встречное вхождение элемента в список.
* Исправлены ошибки в `edb.list.diff`.



- [ ]  #todo