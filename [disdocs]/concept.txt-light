==Not Relative Bases of Data==

=Terms=

* Расширенный столбец — это столбец, в котором можно хранить значения, расширяемые горизонтально. Пример такого столбца в текущей версии движка — "$object_array". Т.е. значение в этом столбце состоит из записей (Свойства предмета), которые можно добавлять и удалять в произвольном порядке. Поиск записи производится по тегу (см. Теги).

=Concept=

Инструментарий типа SQL (structured query language — «язык структурированных запросов»).

* создание в базе данных новой таблицы;
* добавление в таблицу новых записей;
* изменение записей;
* удаление записей;
* выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
* изменение структур таблиц.

Сначала я думал сделать надстройку, которая позволяет работать с базами данных опосредовано. Т.е. разные алгоритмы должны были использовать новый язык запросов к базам, однако это сильно усложнит разные алгоритмы, если рассматривать порядок вызова процедур, как единый алгоритм.

Сейчас концепция такая: нужен механизм, позволяющий базам обращаться друг к другу через простые ссылки, а так же быстро взять из нужной базы нужные данные.

--Почему это потребовалось--

Последняя версия движка работает с базой данных, состоящей из одной единственной таблицы данных, которая в свою очередь включает несколько столбцов:

	$id_array[] - идентификатор объекта.
	$object_array[] - тело объекта
	$position_array[] - позиция, расположение объекта. В качестве расположения объекта указывается идентификатор другого объекта (родительский объект), либо не указывается ничего.
	$include_array[] - дочерний объект. То есть объект, расположенный в позиции текущего объекта. Так реализуется «обратное наследование»
	kolvo_array[] - количество абсолютно идентичных объектов, находящихся в одной позиции. Для непредметных объектов может использоваться не по назначению, например быть меткой или счётчиком.
	charge_array[] - заряд каждого из абсолютно идентичных объектов, находящихся в одной позиции. Для непредметных объектов может использоваться не по назначению, например быть меткой или счётчиком.
	$respawn_array[] - пороговое время, при котором произойдёт респавн объекта.
	$run_array[] - Код в виде текста, который может быть выполнен при обработке объекта.

Это жёсткая таблица, т.е. число столбцов зафиксировано. Расширение идёт вниз, т.е. за счёт увеличения высоты столбцов. Горизонтальное расширение возможно через внесение в столбцы записей с особым синтаксисом (см.тэги). В основном это расширение идёт в столбце "$object_array", и за счёт того, что синтаксис расширения довольно жёсткий, текущие механизмы довольно просто настраивать.

Например, у предметов есть признак класса, типа, вида и т.д., всё это сейчас пишется отдельными видами записей:

	"[supclass]" — так записывается либо сверхкласс, либо тип объекта.
	"<class>" — так записывается класс объекта
	"[np: :np]" — здесь перечисляются типы, к которым относится объект.
	"[:идентификатор_вида:]" — так указывается вид объекта через идентификатор вида.

У предметов есть и другие свойства, которые задаются подобными или более сложными формами записи.

Поскольку для всех объектов в игре (начиная от локаций и заканчивая репликами диалогов) используется одна таблица данных, это упростило написание многих алгоритмов. Однако, это так же привело к тому, что объём этой таблицы данных должен возрасти с увеличением масштаба игры по экспоненте. Соответственно работа с такой таблицей данных замедлит работу игры.

Из этой ситуации только один выход: писать для разного рода объектов (тут мы вводим понятие "Род") собственные таблицы данных. Что приводит нас к выбору одного из двух вариантов:
	
	* Писать для каждой таблицы данных собственные механизмы и обработчики
	* Написать общие механизмы одинаково работающие с любой таблицей данных.

Для примера можно взять процедуру "add.new.obj". Сейчас она предназанчена для работы только с объектами описанной выше таблицы, и по сути представляет собой внесение различных данных в новую строку таблицы:

	# add.new.obj
		! Подпрограмма создаёт новый объект в игре и присваивает ему айдишник
		! Если используется в качестве функции, в результат возвращается ай-дишник
		$args[0] = $args[0]	&	!	 - тело объекта, исходник объекта
		$args[1] = $args[1]	&	!	 - положение, где находится объект
		$args[2] = $args[2]	&	!	 - Ключевое слово (короткое слово, идентификатор вида)
		args[3] = args[3]	&	!	 - количество одинаковых предметов
		args[4] = args[4]	&	!	 - заряд предмета
		$args[5] = $args[5]	&	!	 - динамический код, выполняемый во время действий с предметом.
		args[6] = args[6]	&	!	 - позиция в которую нужно добавить предмет в базе !!!! ВНИМАНИЕ. Если в этой позиции в базе уже есть предмет, он будет затёрт.
		if args[6]<>0: args['num']=args[6] else args['num'] = arrsize('$id_array')
		$object_array[args['num']]=$args[0]	&	!	создаём объекту тело
		! если объект является заголовком или инвентарём или респавнером, его ай-ди 
		if $strfind($args[0],'<заголовок>')<>'' or $args[2] = 'INVENTORY' or $args[2]='RESPAWNER':
			$id_array[args['num']]=$args[2]
		elseif $strfind($args[0],'<link>')<>'':
			$id_array[args['num']]='link.'+TRIM($args[2])
		else
			$id_array[args['num']]=$args[2]+'.'+$func('#rndstr#',8,'буквы и цифры')
		end
		if $strfind($args[0],'<заголовок>')<>'' and instr($args[0],'[respawn.stop]')=0:
			$position_array[args['num']]='RESPAWNER'
		else
			$position_array[args['num']]=$args[1]
		end
		kolvo_array[args['num']]=args[3]
		charge_array[args['num']]=args[4]
		$run_array[args['num']]=$args[5]
		$result = $id_array[args['num']]
	-add.new.obj-

Да, процедура просто вносит данные в новую строку таблицы, однако она делает не только это. Ещё она устанавливает, какие именно данные необходимо внести в тот или иной столбец. Например, идентификаторы некоторых объектов должны генерироваться, для других нет. Для одних необходмо указывать количество, для других нет. Одни нужно вносить в респавнер, другие нет.

Если мы напишем подобную процедуру, скажем, для таблицы данных диалогов, мы сможем учесть в ней подобные моменты, однако это фактически заставит нас написать практически точно такую же процедуру, которая просто вносит в данные в новую строку в таблице данных диалогов.

Мы создадим ещё таблицу данных на следующий род объектов, потом ещё и ещё, и на каждый напишем по новой процедуре, в которых в конце концов запутаемся.

Однако, если мы попытаемся написать общий механизм, который способен вносить данные в любую из ТД, он усложнится за счёт различных условностей. Например, в разных ТД может быть разное число столбцов, до восьми, и они могут быт разного типа (текстового и строкового). Как нам определить, что за данные мы получили, какого они должны быть типа, в какой столбец их вносить.

Первое, что приходит в голову, зафиксировать столбцы в базе данных, например:

	[0] .... $id_array[]
	[1] .... $object_array[]
	[2] .... $position_array[]
	[3] .... $include_array[]
	[4] .... kolvo_array[]
	[5] .... charge_array[]
	[6] .... $respawn_array[]
	[7] .... $run_array[]

Однако, с одной таблицей нам удастся предсказать, в какой процедуре, какой столбец какому аргументу соответсвует. А вот с двумя уже нет. Например, для диалогов нет необходимости в столбце "include", а значит глупо отводить под пустое значение целый аргумент. Или же при поиске дочерних элементов (для объектов сейчас мы можем указать один-два параметра), а для других ТД потребуется больше параметров, но в какие аргументы их вписывать?

Всё это представляется очень сложным, если не прописать заранее. Вот поэтому и нужен какой-то механизм, который будет как-то этим все управлять.

--Что нужно для реализации, и что нужно реализовать--

* Последняя таблица, с которой мы работали, будет текущей, либо можно выставить текущую специальным методом. Выставление текущей таблицы позволяет работать с колонками таблицы, не указывая адрес до колонки.

* Написать синтаксис, одинаково работающий для любых таблиц данных в игре:
	
	Поскольку таблицы будут иметь расширение по горизонтали, то список команд может так же расширяться теоретически до бесконечности, поэтому цепочка команд должна записываться одним аргументом, в отличие от того же модуля Олегуса. Отсюда следует, что необходимо собрать общий парсер для всех команд, который будет разбирать команду на составляющие и отправлять запросы другим составляющим модуля на выполнение инструкций.

	В общем виде вызов такого парсера может записываться так:

		gosub 'sql','bd.new:object'

	Далее для удобства будем указывать только команды, без gosub 'sql' и других мелочей.

* Стандартизировать вид таблиц, чтобы с ними было удобно работать.

	Прежде всего всю базу данных, как абстракцию, нужно рассматривать, как один объект. Технически база данных не существует, пока в ней не появится хоть одна таблица, однако для записи команд мы будем использовать имя 'bd' для обозначения этого объекта.

	В базе данных можно делать только две вещи: создавать и удалять таблицы данных, поэтому пока единственные два "метода" для базы данных — это "newTable" и "delTable". Команда, позволяющая таким образом создать новую таблицу:

		bd.newTable{object}

	Здесь в фигурных скобках мы указываем передаваемые "методу" параметры, в данном случае имя создаваемой таблицы. Можно сразу создать несколько таблиц, при этом параметры перечисляются через запятую:

		bd.newTable{object,personage,dialog,etc}

	Технически создание таблицы инициирует одноимённый массив:

		$object[0]='Data Table:object'
		
	Далее с созданной таблицей 'object' можно работать, как с отдельным объектом. Полный адрес доступа к этому объекту:

		bd.object

	Но разрешается делать краткую запись, просто указывая имя объекта:

		object

	Для работы с таблицами будет предусмотрено несколько методов.

	Чтобы добавить колонки в таблицу, пользуемся методом newCol:

		object.newCol{id,body,position,include,kolvo,charge}

	Полный адрес столбца таким образом выглядит так:

		bd.object.id

	По аналогии с кратким адресом к таблице, можно использовать краткий адрес столбца, т.е.

		id

	однако, такой адрес можно использовать, если таблица помечена, как текущая. Таблица помечается, как текущая, при любом обращении к ней. Предусмотрен явный метод для выставления таблицы как текущей, чтобы упростить читаемость кода:

		object.setCur

	Добавление столбца в таблицу технически создаёт массив, имя которого состоит из названия таблицы и указанного названия столбца. Пример:

		object.newCol{id,body}

	эта команда создаёт два массива '$id_object' и '$body_object', каждый из которых и есть столбец. При этом нулевая ячейка является заголовком столбца, в которой прописывается только информация о столбце. По умолчанию туда прописывается только тип "[type:text]". Текстовый тип — это тип по умолчанию. Пока что для работы со столбцами предусмотрено несколько методов:

		setType — устанавливает тип столбца: числовой или текстовый (по умолчанию все столбцы создаются текстового типа)
		setIndex — устанавливает данный столбец, как индексный. Это позволяет по указанным в столбце значениям индексировать строки.