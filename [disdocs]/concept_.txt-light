==Not Relative Bases of Data==

=Terms=

* Расширенный столбец — это столбец, в котором можно хранить значения, расширяемые горизонтально. Пример такого столбца в текущей версии движка — "$object_array". Т.е. значение в этом столбце состоит из записей (Свойства предмета), которые можно добавлять и удалять в произвольном порядке. Поиск записи производится по тегу (см. Теги).

=Concept=

Инструментарий типа SQL (structured query language — «язык структурированных запросов»).

* создание в базе данных новой таблицы;
* добавление в таблицу новых записей;
* изменение записей;
* удаление записей;
* выборка записей из одной или нескольких таблиц (в соответствии с заданным условием);
* изменение структур таблиц.

Сначала я думал сделать надстройку, которая позволяет работать с базами данных опосредовано. Т.е. разные алгоритмы должны были использовать новый язык запросов к базам, однако это сильно усложнит разные алгоритмы, если рассматривать порядок вызова процедур, как единый алгоритм.

Сейчас концепция такая: нужен механизм, позволяющий базам обращаться друг к другу через простые ссылки, а так же быстро взять из нужной базы нужные данные.

--Почему это потребовалось--

Последняя версия движка работает с базой данных, состоящей из одной единственной таблицы данных, которая в свою очередь включает несколько столбцов:

	$id_array[] - идентификатор объекта.
	$object_array[] - тело объекта
	$position_array[] - позиция, расположение объекта. В качестве расположения объекта указывается идентификатор другого объекта (родительский объект), либо не указывается ничего.
	$include_array[] - дочерний объект. То есть объект, расположенный в позиции текущего объекта. Так реализуется «обратное наследование»
	kolvo_array[] - количество абсолютно идентичных объектов, находящихся в одной позиции. Для непредметных объектов может использоваться не по назначению, например быть меткой или счётчиком.
	charge_array[] - заряд каждого из абсолютно идентичных объектов, находящихся в одной позиции. Для непредметных объектов может использоваться не по назначению, например быть меткой или счётчиком.
	$respawn_array[] - пороговое время, при котором произойдёт респавн объекта.
	$run_array[] - Код в виде текста, который может быть выполнен при обработке объекта.

Это жёсткая таблица, т.е. число столбцов зафиксировано. Расширение идёт вниз, т.е. за счёт увеличения высоты столбцов. Горизонтальное расширение возможно через внесение в столбцы записей с особым синтаксисом (см.тэги). В основном это расширение идёт в столбце "$object_array", и за счёт того, что синтаксис расширения довольно жёсткий, текущие механизмы довольно просто настраивать.

Например, у предметов есть признак класса, типа, вида и т.д., всё это сейчас пишется отдельными видами записей:

	"[supclass]" — так записывается либо сверхкласс, либо тип объекта.
	"<class>" — так записывается класс объекта
	"[np: :np]" — здесь перечисляются типы, к которым относится объект.
	"[:идентификатор_вида:]" — так указывается вид объекта через идентификатор вида.

У предметов есть и другие свойства, которые задаются подобными или более сложными формами записи.

Поскольку для всех объектов в игре (начиная от локаций и заканчивая репликами диалогов) используется одна таблица данных, это упростило написание многих алгоритмов. Однако, это так же привело к тому, что объём этой таблицы данных должен возрасти с увеличением масштаба игры по экспоненте. Соответственно работа с такой таблицей данных замедлит работу игры.

Из этой ситуации только один выход: писать для разного рода объектов (тут мы вводим понятие "Род") собственные таблицы данных. Что приводит нас к выбору одного из двух вариантов:
	
	* Писать для каждой таблицы данных собственные механизмы и обработчики
	* Написать общие механизмы одинаково работающие с любой таблицей данных.

Для примера можно взять процедуру "add.new.obj". Сейчас она предназанчена для работы только с объектами описанной выше таблицы, и по сути представляет собой внесение различных данных в новую строку таблицы:
```qsp
	# add.new.obj
		! Подпрограмма создаёт новый объект в игре и присваивает ему айдишник
		! Если используется в качестве функции, в результат возвращается ай-дишник
		$args[0] = $args[0]	&	!	 - тело объекта, исходник объекта
		$args[1] = $args[1]	&	!	 - положение, где находится объект
		$args[2] = $args[2]	&	!	 - Ключевое слово (короткое слово, идентификатор вида)
		args[3] = args[3]	&	!	 - количество одинаковых предметов
		args[4] = args[4]	&	!	 - заряд предмета
		$args[5] = $args[5]	&	!	 - динамический код, выполняемый во время действий с предметом.
		args[6] = args[6]	&	!	 - позиция в которую нужно добавить предмет в базе !!!! ВНИМАНИЕ. Если в этой позиции в базе уже есть предмет, он будет затёрт.
		if args[6]<>0: args['num']=args[6] else args['num'] = arrsize('$id_array')
		$object_array[args['num']]=$args[0]	&	!	создаём объекту тело
		! если объект является заголовком или инвентарём или респавнером, его ай-ди 
		if $strfind($args[0],'<заголовок>')<>'' or $args[2] = 'INVENTORY' or $args[2]='RESPAWNER':
			$id_array[args['num']]=$args[2]
		elseif $strfind($args[0],'<link>')<>'':
			$id_array[args['num']]='link.'+TRIM($args[2])
		else
			$id_array[args['num']]=$args[2]+'.'+$func('#rndstr#',8,'буквы и цифры')
		end
		if $strfind($args[0],'<заголовок>')<>'' and instr($args[0],'[respawn.stop]')=0:
			$position_array[args['num']]='RESPAWNER'
		else
			$position_array[args['num']]=$args[1]
		end
		kolvo_array[args['num']]=args[3]
		charge_array[args['num']]=args[4]
		$run_array[args['num']]=$args[5]
		$result = $id_array[args['num']]
	-add.new.obj-
```

Да, процедура просто вносит данные в новую строку таблицы, однако она делает не только это. Ещё она устанавливает, какие именно данные необходимо внести в тот или иной столбец. Например, идентификаторы некоторых объектов должны генерироваться, для других нет. Для одних необходмо указывать количество, для других нет. Одни нужно вносить в респавнер, другие нет.

Если мы напишем подобную процедуру, скажем, для таблицы данных диалогов, мы сможем учесть в ней подобные моменты, однако это фактически заставит нас написать практически точно такую же процедуру, которая просто вносит данные в новую строку в таблице данных диалогов.

Мы создадим ещё таблицу данных на следующий род объектов, потом ещё и ещё, и на каждый напишем по новой процедуре, в которых в конце концов запутаемся.

Однако, если мы попытаемся написать общий механизм, который способен вносить данные в любую из ТД, он усложнится за счёт различных условностей. Например, в разных ТД может быть разное число столбцов, до восьми, и они могут быт разного типа (текстового и строкового). Как нам определить, что за данные мы получили, какого они должны быть типа, в какой столбец их вносить.

Первое, что приходит в голову, зафиксировать столбцы в базе данных, например:

	[0] .... $id_array[]
	[1] .... $object_array[]
	[2] .... $position_array[]
	[3] .... $include_array[]
	[4] .... kolvo_array[]
	[5] .... charge_array[]
	[6] .... $respawn_array[]
	[7] .... $run_array[]

Однако, с одной таблицей нам удастся предсказать, в какой процедуре, какой столбец какому аргументу соответсвует. А вот с двумя уже нет. Например, для диалогов нет необходимости в столбце "include", а значит глупо отводить под пустое значение целый аргумент. Или же при поиске дочерних элементов (для объектов сейчас мы можем указать один-два параметра), а для других ТД потребуется больше параметров, но в какие аргументы их вписывать?

Всё это представляется очень сложным, если не прописать заранее. Вот поэтому и нужен какой-то механизм, который будет как-то этим все управлять.

--Что нужно для реализации, и что нужно реализовать--

* Последняя таблица, с которой мы работали, будет текущей, либо можно выставить текущую специальным методом. Выставление текущей таблицы позволяет работать с колонками таблицы, не указывая адрес до колонки.

* Написать синтаксис, одинаково работающий для любых таблиц данных в игре:
	
	Поскольку таблицы будут иметь расширение по горизонтали, то список команд может так же расширяться теоретически до бесконечности, поэтому цепочка команд должна записываться одним аргументом, в отличие от того же модуля Олегуса. Отсюда следует, что необходимо собрать общий парсер для всех команд, который будет разбирать команду на составляющие и отправлять запросы другим составляющим модуля на выполнение инструкций.

	В общем виде вызов такого парсера может записываться так:

		gosub 'sql','bd.new:object'

	Далее для удобства будем указывать только команды, без gosub 'sql' и других мелочей.

* Стандартизировать вид таблиц, чтобы с ними было удобно работать.

	Прежде всего всю базу данных, как абстракцию, нужно рассматривать, как один объект. Технически база данных не существует, пока в ней не появится хоть одна таблица, однако для записи команд мы будем использовать имя 'bd' для обозначения этого объекта.

	В базе данных можно делать только две вещи: создавать и удалять таблицы данных, поэтому пока единственные два "метода" для базы данных — это "newTable" и "delTable". Команда, позволяющая таким образом создать новую таблицу:

		bd.newTable{object}

	Здесь в фигурных скобках мы указываем передаваемые "методу" параметры, в данном случае имя создаваемой таблицы. Можно сразу создать несколько таблиц, при этом параметры перечисляются через запятую:

		bd.newTable{object,personage,dialog,etc}

	Технически создание таблицы инициирует одноимённый массив:

		$object[0]='Data Table:object'
		
	Далее с созданной таблицей 'object' можно работать, как с отдельным объектом. Полный адрес доступа к этому объекту:

		bd.object

	Но разрешается делать краткую запись, просто указывая имя объекта:

		object

	Для работы с таблицами будет предусмотрено несколько методов.

	Чтобы добавить колонки в таблицу, пользуемся методом newCol:

		object.newCol{id,body,position,include,kolvo,charge}

	Полный адрес столбца таким образом выглядит так:

		bd.object.id

	По аналогии с кратким адресом к таблице, можно использовать краткий адрес столбца, т.е.

		id

	однако, такой адрес можно использовать, если таблица помечена, как текущая. Таблица помечается, как текущая, при любом обращении к ней. Предусмотрен явный метод для выставления таблицы как текущей, чтобы упростить читаемость кода:

		object.setCur

	Добавление столбца в таблицу технически создаёт массив, имя которого состоит из названия таблицы и указанного названия столбца. Пример:

		object.newCol{id,body}

	эта команда создаёт два массива '$id_object' и '$body_object', каждый из которых и есть столбец. При этом нулевая ячейка является заголовком столбца, в которой прописывается только информация о столбце. По умолчанию туда прописывается только тип "[type:text]". Текстовый тип — это тип по умолчанию. Пока что для работы со столбцами предусмотрено несколько методов:

		setType — устанавливает тип столбца: числовой или текстовый (по умолчанию все столбцы создаются текстового типа)
		setIndex — устанавливает данный столбец, как индексный. Это позволяет по указанным в столбце значениям индексировать строки.

		-Индексы-

		Довольно сложной представляется реализация индексов в таблице. Мы имеем дело с объектами, идентификаторы которых отвязаны от индексов строк таблицы. То есть объект хранится в одной строке, но не имеет жёсткой привязки к номеру этой строки. Если объекты выше будут удалены из таблицы, соответственно изменятся и номера строк нижних объектов, они сдвинутся вверх (то есть уменьшатся). Это порождает необходимость производить поиск номера строки всякий раз, когда мы хотим обратиться к объекту.
		Куда как проще было бы, если бы каждая строка таблицы была связана с конкретным текстовым индексом, а этот текстовый индекс по значению совпадал с айди объекта. Тогда обратиться к нужной строке можно было бы просто зная идентификатор объекта. Это приводит нас к следующему:

			* Индексный столбец содержит в себе идентификаторы объектов, в то же время эти идентификаторы выступают индексами индексного столбца. пример:

				$id_object['00000001']='00000001'
				$id_object['00000013']='00000013'
				$id_object['09999999']='09999999'

			* Все остальные ячейки строки так же индексируются не по числовым значениям, а по текстовым. Но, поскольку при добавлении строки происходит добавление данных во все столбцы, таким же образом можно вычислить и номер конкретной строки в таблице. Метод тот же, что и в текущей реализации

				pos=arrpos('$id_object','00000001')

		Таким образом для того, чтобы сослаться на объект (строку), достаточно знать его идентификатор. Как это реализовать в инструкциях, интересный вопрос. Ещё подумаем.

		Следующая проблема с индексами заключается в том, что сейчас они генерируются случайным образом. Это не очень удобно в плане производительности, поскольку приходится проверять, не существует ли уже такой индекс в таблице, а если таблица будет состоять из ста тысяч элементов, это существенно замедлит даже простое добавление строки (объекта). Это означает, что нам нужен иной способ генерации индексов, нежели случайным образом. Тут мы можем положиться на простой счётчик. Где разместить этот счётчик? Это как раз довольно легко. Счётчик размещаем в ячейке object['idx_count'] нашей таблицы. Каждый раз, как мы добавляем новую строку к таблице, этот счётчик должен увеличиваться на единицу. Идентификатор объекта, соответственно индекс строки можно приводить к строковому типу, добивая недостающие до определённой длины символы нулями.
		Это опять создаёт для нас проблему. Когда мы удаляем строку из таблицы, вместе с ней мы теряем и индекс. Что в конечном итоге приведёт к переполнению счётчика даже при небольшом числе объектов одномоментно в игре, если игра будет достаточно продолжительной. Значит нам нужно как-то сохранять индексы удалённых строк, чтобы потом эти индексы использовать повторно. Хорошо бы завести отдельный массив, но этот массив придётся как-то связывать с таблицей, то есть генерировать через dynamic, а мы и так уже многое сгенерировали, так что наверное придётся вести список ай-ди в текстовом виде в отдельной ячейке созданной таблицы данных.

			$object['deleted_idx']='00000001,00000013,09999999,'

		^: По прошествии времени данная проблема выглядит надуманной. Мы ведь создаём уникальные идентификаторы, и счётчик - просто способ сделать эти идентификаторы уникальными. Мы можем использовать шестнадцатеричные числа для записи счётчика и просто прибавлять к шестнадцатеричному числу по единице. Строка не имеет ограничения по длине, и мы успеем создать больше 4 млрд строк, пока не достигнем значения "ffffffff". Таким образом идентификатор можно генерировать случайным образом и прибавлять к нему значение счётчика, или просто создавать новое значение счётчика при генерации новой строки в базе.

		-Техническая реализация поддержки множества столбцов-

		Да, непосредственно столбцы будут генерироваться, и вообще сама база будет работать целиком на динамиках. То есть мы будем иметь дело с массивами. Но мы будем точно знать, с каким массивом работать, когда по имени обращаемся к столбцу. Если нам нужно например создать строку, механизм не знает, какие столбцы вообще существуют в таблице. То есть нам необходимо в самой таблице описать присутствующие в ней столбцы. придётся завести ещё ячейку, где будут храниться хотя бы названия столбцов:

			$object['cols']='id,body,position,include,kolvo,charge,'

		Отсюда методом перебора можно извлекать названия, и уже с помощью dynamic по очереди генерировать столбцы.

=Команды=

понятно, что удобно писать команды по аналогии с объектами и доступом к объектам, как в других языках программирования, т.е.

bd.object.body...

и т.д, однако возникает вопрос с передачей аргументов внутрь такой команды. аргументы перечисляются через запятую внутри фигурных скобок, это хорошо, потому что фигурные скобки используются крайне редко, а вот запятыми дело обстоит сложнее, но предположим.
