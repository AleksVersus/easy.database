# Словари

В языках типа python и js словари являются хэштаблицами, тогда как в QSP нам доступны только три типа данных:

- числа
- строки
- кортежи

По сути словарь представляет собой структуру, состоящую из пар `ключ - значение`. Это позволяет обращаться к значению по ключу.

Мы можем использовать динамический код для организации таких пар. В качестве ключей можно использовать переменные, а в качестве значений — значения, помещённые в эти переменные.

Для наглядности я написал вот такой словарь:

```qsp
$dict = {
	$kind = "деревянная_булава"
	$name = "Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине"
	number = 1
	$np = "оружие|одноручное|булава"
	stoim = 176
	weight = 50
	$color = "663300"
	$uron = {
		дробящий = 1000
		стрелковый = 125
	}
}

dynamic $dict
```

Как видно, в такой структуре данных мы можем хранить, как простые строки, числа и кортежи, так и другие словари. По сути вложенность словарей не ограничена, и при воспроизведении верхнего уровня словаря, мы получаем все вложенные словари, как значение одной из воспроизведённых переменных.

Однако в чистом виде эта структура может поломать данные в переменных с пересекающимися именами, поэтому для автора мы оставляем чистую структуру, только как своего рода синтаксический сахар, если нужно быстро написать словарь.

Технически же словарь будет иметь немного иную структуру данных.

## Общая структура

Поскольку ключами словаря являются имена переменных, в словаре нужно объявить по локальной переменной на каждый ключ.

Дабы исключить возможные пересечения имён с другими переменными, в самом словаре переменные должны иметь неудобные имена. В `easy.database` имена переменных внутри словарей оборачиваются в двойные символы нижнего подчёркивания:

```qsp
local $__name__
local $__weight__
```

Все переменные на уровне словаря имеют только текстовый тип для удобства. Однако данные, которые сохраняются в словаре могут быть разных типов. Поэтому непосредственно запись данных выглядит как значения в ячейках `'type'` и `'value'` указанного массива. Пример:

```qsp
local $__name__
$__name__['type'] = 'str'
$__name__['value'] = 'Дубина'
```

Cобственно на этом структура словаря и заканчивается.

Да, если мы выполним такой словарь просто как самостоятельный динмаический код, мы не увидим никакого результата, разве что на время забьём память. Однако, мы можем заранее написать функции, обслуживающие словари, которые и позволят автору взаимодействовать с данными, извлекать, обновлять, дополнять. Всё это возможно, если к основному динамическому коду словаря добавлять динамический код для работы с данными.

Например, если мы хотим узнать существует ли в словаре некий ключ, нам нужно только лишь получить размер массива, соответствующего этому ключу и вернуть результат. Вот такой динамический код мы присоединяем к коду словаря:

```qsp
result = arrsize('$__<<$args[0]>>__')
```

и таким образом, вызвав весь собранный код с помощью `dyneval`, с передачей ключа в качестве параметра, мы получим информацию о существовании ключа.

Вся функция проверки ключа в словаре будет выглядеть так:

```qsp
result = dyneval($args[0] + @em.RN + {result = arrsize('$__<<$args[0]>>__')}, $args[1])
```

, где `$args[0]` — словарь, `$args[1]` — ключ, `@em.RN` — константа символа переноса строки.

## Достоинства и недостатки

**Достоинства:**
+ Высокая скорость извлечения всех данных словаря.
+ Возможность вкладывать словари друг в друга с использованием повторяющихся ключей.
+ простота доступа к данным на любом из уровней
+ Простота генерации одноуровневых словарей

**Недостатки:**
- Ключи должны соответствовать требованиям к именам переменных в QSP.
- При изменении данных во вложенных словарях приходится извлекать подряд данные всех словарей до нужного уровня, пересобирать данные в самом нижнем словаре, затем возвращаться обратно и пересобирать все словари вплоть до верхнего уровня.
- нагрузка на память при большом числе вложенных словарей, или данных (может привести к переполнению хэша переменных в QSP)
- поскольку данные изолированы внутри словаря, извлечь из него одновременно все данные проблематично (но не невозможно).
- по сравнению с другими способами хранения данных, словарь требует намного большего объёма памяти для хранения. Ниже для сравнения представлен словарь, основанный на тегированной записи, и текущая модель того же самого словаря.

### Сравнение словарей разных типов

**Тегированный**

Это почти точное воспроизведение словаря, использующегося в движке "MAGIKON.FB", написанном на QSP. Этот словарь одновременно легко писать вручную и занимает он не очень много места.

```qsp
[kind:деревянная_булава]
[name:Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине:name]
[number]
[np:[оружие] [одноручное] [булава]:np]
[stoim:176]
[weight:50]
[color:663300]
[uron:[p1:дробящий:p1] [p2:стрелковый:p2] [u1:1000:u1] [u2:125:u2]:uron]
```

**Через динамический код**

Тот же самый словарь в виде динамического кода:

```qsp
local $__uron__
local $__weight__
local $__stoim__
local $__number__
local $__color__
local $__np__
local $__name__
local $__kind__
$__kind__['type'] = 'str'
$__kind__['value'] = 'деревянная_булава'
$__name__['type'] = 'str'
$__name__['value'] = 'Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине'
$__np__['type'] = 'str'
$__np__['value'] = 'оружие|одноручное|булава'
$__color__['type'] = 'str'
$__color__['value'] = '663300'
$__number__['type'] = 'num'
$__number__['value'] = '1'
$__stoim__['type'] = 'num'
$__stoim__['value'] = '176'
$__weight__['type'] = 'num'
$__weight__['value'] = '50'
$__uron__['type'] = 'dict'
$__uron__['value'] = {local $__стрелковый__
local $__дробящий__
$__дробящий__['type'] = 'num'
$__дробящий__['value'] = '1000'
$__стрелковый__['type'] = 'num'
$__стрелковый__['value'] = '125'
}
```

239 символов для первого случая против 804 для второго случая. Особенно невыгоден такой словарь, если нужно сохранить ряд числовых значений.

## подготовленные функции:

- `edb.dict.is_key` — функция описанная выше. Проверяет наличие ключа в словаре.
- `edb.dict.get_keys` — функция получает все ключи словаря в виде списка типа `aaaa|bbbb|...|zzzz`.
- `edb.dict.get_value` — получает значение по ключу.
- `edb.dict.get_inner` — просматривает словарь вглубь по ключам, погружаясь во вложенные словари. Ключи указываются отдельными аргументами.
- `edb.dict.deep` — просматривает словарь вглубь по ключам, погружаясь во вложенные словари. Ключи указываются одним аргументом в виде цепочки типа `aaaa.bbbb.zzzz`.
- `edb.dict.add` — добавляет значение в словарь, либо изменяет существующее, если ключ уже присутствует в словаре.
- `edb.dict.new` — создаёт словарь с валидным для механизма наполнением. В качестве аргумента нужно передавать словарь, написанный с использованием упрощённого синтаксиса.

## Пример создания словаря и работы с ним

```qsp
local $obj_ = {
	дробящий = 1000
	стрелковый = 125
}

local $uron_dict_ = @edb.dict.new($obj_)

!@ используется упрощённый синтаксис для записи словаря в коде.
!@ фактически это валидный код QSP:
$obj_ = {
	$kind = "деревянная_булава"
	$name = "Дубина|Дубины|Дубине|Дубину|Дубиной|Дубине"
	number = 1
	$np = "оружие|одноручное|булава"
	stoim = 176
	weight = 50
	$color = "663300"	
}
!@ создаём словарь
$dict_ = @edb.dict.new($obj_)
*pl $dict_
*pl '...'
!@ пробуем получить значения
*pl @edb.dict.get_value($dict_, 'name')
*pl @edb.dict.get_value($dict_, 'weight')
*pl @edb.dict.get_value($dict_, 'uron')
*pl '...'
!@ добавляем словарь в словарь
$dict_ = @edb.dict.add($dict_, 'uron', $uron_dict_, 'dict')
*pl $dict_
*pl @edb.dict.get_value($dict_, 'name')
*pl @edb.dict.get_value($dict_, 'дробящий')
*pl @edb.dict.get_value($dict_, 'uron')
*pl @edb.dict.deep($dict_, 'uron.стрелковый', '[with_type]')
*pl @edb.dict.get_inner($dict_, 'uron', 'дробящий', '[with_type]')
!@ проверяем, существуют ли ключи
@edb.dict.is_key($dict_, 'uron')
@edb.dict.is_key($dict_, 'nume')
!@ получаем список всех ключей в словаре
@edb.dict.get_keys($dict_)
```